<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced.
     An alternate method (rfc include) is described in the references. -->


<!ENTITY RFC2119 SYSTEM
"http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC4279 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4279.xml">
<!ENTITY RFC4680 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4680.xml">
<!ENTITY RFC4949 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4949.xml">
<!ENTITY RFC5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY RFC6347 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6347.xml">
<!ENTITY RFC6690 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6690.xml">
<!ENTITY RFC6749 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6749.xml">
<!ENTITY RFC6750 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6750.xml">
<!ENTITY RFC6819 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6819.xml">
<!ENTITY RFC7049 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7049.xml">
<!ENTITY RFC7159 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7159.xml">
<!ENTITY RFC7228 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7228.xml">
<!ENTITY RFC7231 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7231.xml">
<!-- <!ENTITY RFC7250 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7250.xml"> -->
<!ENTITY RFC7252 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7252.xml">
<!ENTITY RFC7519 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7519.xml">
<!ENTITY RFC7517 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7517.xml">
<!-- <!ENTITY I-D.ietf-ace-usecases SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-ace-usecases.xml"> -->
<!ENTITY I-D.ietf-oauth-introspection SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-introspection.xml">
<!ENTITY I-D.somaraju-ace-multicast SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.somaraju-ace-multicast.xml">
<!ENTITY I-D.ietf-ace-actors SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-ace-actors.xml">
<!ENTITY I-D.ietf-cose-msg SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-cose-msg.xml">
<!ENTITY I-D.selander-ace-object-security SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.selander-ace-object-security.xml">
<!ENTITY I-D.ietf-oauth-pop-architecture SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-pop-architecture.xml">
<!ENTITY I-D.ietf-oauth-pop-key-distribution SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-pop-key-distribution.xml">
<!ENTITY I-D.wahlstroem-ace-oauth-introspection SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.wahlstroem-ace-oauth-introspection.xml">
<!ENTITY I-D.wahlstroem-ace-cbor-web-token SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.wahlstroem-ace-cbor-web-token.xml">
<!ENTITY I-D.bormann-core-ace-aif SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.bormann-core-ace-aif.xml">
<!ENTITY I-D.ietf-core-block SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-core-block.xml">
<!ENTITY I-D.seitz-ace-core-authz SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.seitz-ace-core-authz.xml">
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-ietf-ace-oauth-authz-00" ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN"
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
        full title is longer than 39 characters -->

    <title abbrev="OAuth 2.0 IoT Authorization">Authorization for the Internet of Things using OAuth 2.0</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Ludwig Seitz" initials="L." surname="Seitz">
      <organization>SICS</organization>

      <address>
        <postal>
          <street>Scheelevaegen 17</street>
          <code>223 70</code> <city>Lund</city>
          <country>SWEDEN</country>
        </postal>
        <email>ludwig@sics.se</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Goeran Selander" initials="G." surname="Selander">
      <organization>Ericsson</organization>

      <address>
        <postal>
          <street>Faroegatan 6</street>
          <code>164 80</code> <city>Kista</city>
          <country>SWEDEN</country>
        </postal>
        <email>goran.selander@ericsson.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Erik Wahlstroem" initials="E." surname="Wahlstroem">
      <organization>Nexus Technology</organization>

      <address>
        <postal>
          <street>Telefonvagen 26</street>
          <code>126 26</code> <city>Hagersten</city>
          <country>Sweden</country>
        </postal>
        <email>erik.wahlstrom@nexusgroup.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Samuel Erdtman" initials="S." surname="Erdtman">
      <organization>Nexus Technology</organization>

      <address>
        <postal>
          <street>Telefonvagen 26</street>
          <code>126 26</code> <city>Hagersten</city>
          <country>Sweden</country>
        </postal>
        <email>samuel.erdtman@nexusgroup.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Hannes Tschofenig" initials="H." surname="Tschofenig">
      <organization>ARM Ltd.</organization>

      <address>
        <postal>
          <street></street>
          <code>6060</code> <city>Hall in Tirol</city>
          <country>Austria</country>
        </postal>
        <email>Hannes.Tschofenig@arm.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>
    <date year="2016" />



    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
         in the current day for you. If only the current year is specified, xml2rfc will fill
	 in the current day and month for you. If the year is not the current one, it is
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to
	 specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>Security</area>

    <workgroup>ACE Working Group</workgroup>

    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.
	 If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>CoAP, OAuth 2.0, Access Control, Authorization, Internet of Things</keyword>

    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t>This memo defines how to use OAuth 2.0 as an authorization framework
      with Internet of Things (IoT) deployments, thus bringing a well-known and
      widely used security solution to IoT devices.  Where possible vanilla
      OAuth 2.0 is used, but where the limitations of IoT devices require it,
      profiles and extensions are provided.
      </t>
    </abstract>
  </front>

<middle>


<!-- ***************************************************** -->

<section anchor="intro" title="Introduction">

<t>Authorization is the process for granting approval to an entity to access a
resource <xref target="RFC4949"/>.  Managing authorization information for a 
large number of devices and users is often a complex task where dedicated 
servers are used.</t>

<t>Managing authorization of users, services and their devices with the help of
dedicated authorization servers (AS) is a common task, found in enterprise
networks as well as on the Web.  In its simplest form the authorization task can
be described as granting access to a requesting client, for a resource hosted on 
a device, the resource server (RS).  This exchange is mediated by one or multiple 
authorization servers.</t>

<t>We envision that end consumers and enterprises will want to manage access-control and authorization for their
Internet of Things (IoT) devices in the same style and this desire will increase
with the number of exposed services and capabilities provided by applications 
hosted on the IoT devices.  The IoT devices may be constrained in various ways 
including processing, memory, code-size, energy, etc., as defined in
<xref target="RFC7228"/>, and the different IoT deployments present a continuous
range of device and network capabilities.  Taking energy consumption as an
example: At one end there are energy-harvesting or battery powered devices which 
have a tight power budget, on the other end there are devices connected to
a continuous power supply which are not constrained in terms of power, and all 
levels in between.  Thus IoT devices are very different in terms of available 
processing and message exchange capabilities.
</t>

<t>This memo describes how to re-use OAuth 2.0 <xref target="RFC6749"/> to
extend authorization to Internet of Things devices with different kinds of
constraints.  At the time of writing, OAuth 2.0 is already used with certain
types of IoT devices and this document will provide implementers additional
guidance for using it in a secure and privacy-friendly way.  Where possible the
basic OAuth 2.0 mechanisms are used; in some circumstances profiles are defined,
for example to support smaller the over-the-wire message size and
smaller code size.</t>
</section>

<!-- ***************************************************** -->

<section anchor="terminology" title="Terminology">
  <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in
this document are to be interpreted as described in <xref
target="RFC2119"/>.  </t>

  <t>Certain security-related terms such as "authentication",
"authorization", "confidentiality", "(data) integrity", "message
authentication code", and "verify" are taken from <xref
target="RFC4949"/>.
  </t>

  <t>Since we describe exchanges as RESTful protocol interactions HTTP
<xref target="RFC7231"/> offers useful terminology.
  </t>

  <t>Terminology for entities in the architecture is defined in OAuth
2.0 <xref target="RFC6749"/> and <xref target="I-D.ietf-ace-actors"/>,
such as client (C), resource server (RS), and authorization server
(AS).  OAuth 2.0 uses the term "endpoint" to denote HTTP resources such as 
/token and /authorize at the AS, but we will use the term "resource" in this 
memo to avoid confusion with the CoAP <xref target="RFC7252"/> term 
"endpoint".</t>

<t>
Since this draft focuses on the problem of access control to resources, we
simplify the actors by assuming that the client authorization server (CAS)
functionality is not stand-alone but subsumed by either the authorization server
or the client (see section 2.2 in <xref target="I-D.ietf-ace-actors"/>).
</t>

</section>

<!-- ***************************************************** -->

<section anchor="overview" title="Overview">

  <t>This specification describes a framework for authorization in the Internet
      of Things consisting of a set of building blocks.</t>

  <t>
  The basic block is the OAuth 2.0 <xref target="RFC6749"/>
  framework, which enjoys widespread deployment.  Many IoT devices can support
  OAuth 2.0 without any additional extensions, but for certain constrained
  settings additional profiling is needed.
  </t>

  <t>Another building block is the lightweight web transfer protocol CoAP
  <xref target="RFC7252"/> for those communication environments where HTTP is
  not appropriate.  CoAP typically runs on top of UDP which further reduces
  overhead and message exchanges.  Transport layer security can be provided
  either by DTLS 1.2 <xref target="RFC6347"/> or TLS 1.2 
  <xref target="RFC5246"/>.
  </t>

  <t>A third building block is CBOR <xref target="RFC7049"/> for encodings
  where JSON <xref target="RFC7159"/> is not sufficiently compact.  CBOR is a 
  binary encoding designed for extremely small code size and fairly small
  message size.  OAuth 2.0 allows access tokens to use different encodings and 
  this document defines such an alternative encoding.  The COSE message format 
  <xref target="I-D.ietf-cose-msg"/> is also based on CBOR.
  </t>

  <t>A fourth building block is application layer security, which is used
  where transport layer security is insufficient.  At the time of writing
  the preferred approach for securing CoAP at the application layer is via the
  use of COSE <xref target="I-D.ietf-cose-msg"/>, which adds object security to
  CBOR-encoded data.  More details about applying COSE to CoAP can be found in
  OSCOAP <xref target="I-D.selander-ace-object-security"/>.
  </t>

  <t>With the building blocks listed above, solutions satisfying various
  IoT device and network constraints are possible.  A list of constraints is
  described in detail in RFC 7228 <xref target="RFC7228"/> and a description
  of how the building blocks mentioned above relate to the various constraints
  can be found in <xref target="constraints"/>.</t>


  <t>Luckily, not every IoT device suffers from all constraints.  The described
  framework nevertheless takes all these aspects into account and allows 
  several different deployment variants to co-exist rather than mandating a
  one-size-fits-all solution.  We believe this is important to cover the wide
  range of possible interworking use cases and the different requirements from 
  a security point of view.  Once IoT deployments mature, popular deployment
  variants will be documented in form of profiles.</t>

  <t>In the subsections below we provide further details about the different
  building blocks.</t>

  <section anchor="oauth2Overview" title="OAuth 2.0">
    <t>The OAuth 2.0 authorization framework enables a client to obtain
    limited access to a resource with the permission of a resource 
    owner.  Authorization related information is passed between the nodes
    using access tokens.  These access tokens are issued to clients by an
    authorization server with the approval of the resource owner.  The client
    uses the access token to access the protected resources hosted by the
    resource server.</t>

    <t>A number of OAuth 2.0 terms are used within this memo:

    <list style="hanging">

      <t hangText="Access Tokens:"><vspace blankLines="1"/>
        Access tokens are credentials used to access protected resources.  An
        access token is a data structure representing authorization permissions
        issued to the client.  Access tokens are generated by the authorization 
        server and consumed by the resource server.  The access token is opaque 
        to the client.
        <vspace blankLines="1"/>
        Access tokens can have different formats, and various methods
        of utilization (e.g., cryptographic properties) based on the security
        requirements of the given deployment.
      </t>

      <t hangText="Proof of Possession Tokens:"><vspace blankLines="1"/>
        An access token may be bound to a
        cryptographic key, which is then used by an RS to authenticate requests
        from a client.  Such tokens are called proof-of-possession tokens (or
        PoP tokens) <xref target="I-D.ietf-oauth-pop-architecture"/>.
        <vspace blankLines="1"/>
        The proof-of-possession (PoP) security concept assumes that the AS acts
        as a trusted third party that binds keys to access tokens.  These so
        called PoP keys are then used by the client to demonstrate the
        possession of the secret to the RS when accessing the resource.  The
        RS, when receiving an access token, needs to verify that the key used
        by the client matches the one included in the access token.  When this 
        memo uses the term "access token" it is assumed to be a PoP token unless
        specifically stated otherwise.

        <vspace blankLines="1"/>
        The key bound to the access token (aka PoP key) may be based on
        symmetric as well as on asymmetric cryptography.  The appropriate
        choice of security depends on the constraints of the IoT devices as
        well as on the security requirements of the use case.

        <list style="hanging">
          <t hangText="Symmetric PoP key:"><vspace blankLines="1"/>
              The AS generates a random symmetric PoP key, encrypts it for the 
              RS and includes it inside an access token.  The PoP key is also
              encrypted for the client and sent together with the access token
              to the client.
          </t>
          <t hangText="Asymmetric PoP key:"><vspace blankLines="1"/>
              An asymmetric key pair is generated on the client and the public
              key is sent to the AS (if it does not already have knowledge of
              the client's public key).  Information about the public key,
              which is the PoP key in this case, is then included inside the
              access token and sent back to the requesting client.  The RS
	      can identify the client's public key from the information in the
	      token, which allows the client to use the corresponding private
	      key for the proof of possession.
          </t>
        </list>
        <vspace blankLines="1"/> The access token is
        protected against modifications using a MAC or a digital signature
        of the AS.  The choice of PoP key does not necessarily imply a specific
        credential type for the integrity protection of the token.  More
        information about PoP tokens can be found in
        <xref target="I-D.ietf-oauth-pop-architecture"/>.
      </t>

      <t hangText="Scopes and Permissions:"><vspace blankLines="1"/>
         In OAuth 2.0, the client specifies the type of permissions it is
         seeking to obtain (via the scope parameter) in the access request.  In
         turn, the AS may use the "scope" response parameter to inform the
         client of the scope of the access token issued.  As the client could
	 be a constrained device as well, this memo uses CBOR encoded messages 
         defined in <xref target="app:cborMappingsForOAuth2Properties" /> to 
         request scopes and to be informed what scopes the access token was 
         actually authorized for by the AS.
         <vspace blankLines="1"/>
         The values of the scope parameter are expressed as a list of space-
         delimited, case-sensitive strings, with a semantic that is well-known
	 to the AS and the RS.
         <!-- <vspace blankLines="1"/>
         A common missconception is that the requested scopes must
         also be included in the returned access token, but the requested scopes
         are only metadata about the token.  They could also be packaged in the
         token as a separate attribute, but it's more common to assert the
         requested and authorized access using claims within the access token.
         <vspace blankLines="1"/>-->
         More details about the concept of scopes is found under Section 3.3 in
         <xref target="RFC6749" />.
      </t>


      <t hangText="Claims:"><vspace blankLines="1"/>

        The information carried in the access token in the form of type-value 
        pairs is called claims.  An access token may for example include a claim
        about the AS that issued the token (the "iss" claim) and what audience
        the access token is intended for (the "aud" claim).  The audience of an
        access token can be a specific resource or one or many resource 
        servers.  The resource owner policies influence the what claims are put 
        into the access token by the authorization server.
        <vspace blankLines="1"/>
        While the structure and encoding of the access token varies throughout 
        deployments, a standardized format has been defined with the JSON Web 
        Token (JWT) <xref target="RFC7519"/> where claims are encoded as a JSON 
        object.  In <xref target="I-D.wahlstroem-ace-cbor-web-token"/> an
	equivalent format using CBOR encoding (CWT) has been defined.
      </t>

      <t hangText="Introspection:"><vspace blankLines="1"/>
        Introspection is a method for a resource server to query the
        authorization server for the active state and content of a received
        access token.  This is particularly useful in those cases where the
        authorization decisions are very dynamic and/or where the received
        access token itself is a reference rather than a self-contained
        token.   More information about introspection in OAuth 2.0 can be
        found in <xref target="I-D.ietf-oauth-introspection"/>.
      </t>
    </list>
  </t>
</section>

<section anchor="coap" title="CoAP">

    <t>
    CoAP is an application layer protocol similar to HTTP, but specifically
    designed for constrained environments.  CoAP typically uses
    datagram-oriented transport, such as UDP, where reordering and loss
    of packets can occur.  A security solution need to take the latter aspects
    into account.</t>

    <t>While HTTP uses headers and query-strings to convey additional
    information about a request, CoAP encodes such information in so-called
    'options'.</t>

    <t>CoAP supports application-layer fragmentation of the CoAP payloads
    through blockwise transfers <xref target="I-D.ietf-core-block"/>.  However,
    this method does not allow the fragmentation of large CoAP options,
    therefore data encoded in options has to be kept small.
   <!-- Note that the use of block transfers prevents
        end-to-end security since
    some operations by proxies requires access to meta-data. --> </t>

</section>

<section anchor="objectsecurity" title="Object Security">

  <t>Transport layer security is not always sufficient and application layer
  security has to be provided.  COSE <xref target="I-D.ietf-cose-msg"/> defines
  a message format for cryptographic protection of data using CBOR encoding.
  There are two main approaches for application layer security:

  <list style="hanging">
    <t hangText="Object Security of CoAP (OSCOAP)"><vspace blankLines="1"/>
    OSCOAP <xref target="I-D.selander-ace-object-security"/> is a method for
    protecting CoAP request/response message exchanges, including CoAP
    payloads, CoAP header fields as well as CoAP options.  OSCOAP provides
    end-to-end confidentiality, integrity and replay protection, and a secure
    binding between CoAP request and response messages.
    <vspace blankLines="1"/>
    A CoAP message
    protected with OSCOAP contains the CoAP option "Object-Security"
    which signals that the CoAP message carries a COSE message
    (<xref target="I-D.ietf-cose-msg"/>).  OSCOAP defines a profile of COSE
    which includes replay protection.</t>

    <t hangText="Object Security of Content (OSCON)"><vspace blankLines="1"/>
    For the case of wrapping of application layer payload data ("content")
    only, such as resource representations or claims of access tokens,
    the same COSE profile can be applied to obtain end-to-end
    confidentiality, integrity and replay protection.
    <xref target="I-D.selander-ace-object-security"/> defines this functionality
    as Object Security of Content (OSCON).
    <vspace blankLines="1"/>
    In this case, the message is not
    bound to the underlying application layer protocol and can therefore be used
    with HTTP, CoAP, Bluetooth Smart, etc.  While OSCOAP integrity protects
    specific CoAP message meta-data like request/response code, and binds a
    response to a specific request, OSCON protects only payload/content,
    therefore those security features are lost.  The advantages are that an 
    OSCON message can be passed across different protocols, from request to 
    response, and used to secure group communications.
   <!-- <vspace blankLines="1"/>
    OSCON is, for example, used in this memo for protection of CBOR Web Tokens 
    (CWT) and in example <xref target="ExRSKindaOff"/>.-->
    </t>
  </list></t>
</section>
</section>


<!-- ***************************************************** -->
<section anchor="specs" title="Protocol Interactions">

<t>
    This framework is based on the same protocol interactions as OAuth 2.0:
    A client obtains an access token from an AS and presents the token
    to an RS to gain access to a protected resource.  These interactions are
    shown in <xref target="fig:protocolFlow"/>.  An overview of various OAuth 
    concepts is provided in <xref target="oauth2Overview"/>.
</t>

<t>
    The consent of the resource owner, for giving a client access to a protected
    resource, can be pre-configured authorization policies or dynamically at the
    time when the request is sent.  The resource owner and the requesting
    party (= client owner) are not shown in <xref target="fig:protocolFlow"/>.
</t>

<t>
  For the description in this document we assume that the client has been 
  registered to an AS.  Registration means that the two share credentials, 
  configuration parameters and that some form of authorization has taken 
  place.  These credentials are used to protect the token request by the 
  client and the transport of access tokens and client information from AS 
  to the client. </t> 

 <t>It is also assumed
  that the RS has been registered with the AS.  Established keying material 
between the AS and the RS allows the AS to apply cryptographic protection 
to the access token to ensure that the content cannot be modified, and if
needed, that the content is confidentiality protected.</t> 

<t>The keying material necessary for establishing communication security
  between C and RS is dynamically established as part of the protocol described 
  in this document.
</t>

<t>
    At the start of the protocol there is an optional discovery step where the
    client discovers the resource server and the resources this server hosts.
    In this step the client might also determine what permissions are needed to
    access the protected resource.  The exact procedure depends on the
    protocols being used and the specific deployment environment.  In Bluetooth
    Smart, for example, advertisements are broadcasted by a peripheral,
    including information about the supported services.  In CoAP, as a second
    example, a client can makes a request to "/.well-known/core" to obtain
    information about available resources, which are returned in a
    standardized format as described in <xref target="RFC6690"/>.
</t>

<t><figure align="center" anchor="fig:protocolFlow"
           title="Overview of the basic protocol flow">
  <artwork align="left"><![CDATA[
+--------+                                     +---------------+
|        |---(A)-- Token Request ------------->|               |
|        |                                     | Authorization |
|        |<--(B)-- Access Token ---------------|    Server     |
|        |       + Client Information          |               |
|        |                                     +---------------+
|        |                                            ^ |
|        |        Introspection Request & Response (D)| |(E)
| Client |                                            | v
|        |                                     +--------------+
|        |---(C)-- Token + Request ----------->|              |
|        |                                     |   Resource   |
|        |<--(F)-- Protected Resource ---------|    Server    |
|        |                                     |              |
+--------+                                     +--------------+
  ]]></artwork>
</figure></t>

<t>
  <list style="hanging">
    <t hangText="Requesting an Access Token (A):"><vspace blankLines="1"/>
      The client makes an access token request to the AS.  This memo assumes
      the use of PoP tokens (see <xref target="oauth2Overview"/> for a short
      description) wherein the AS binds a key to an access token.  The client
      may include permissions it seeks to obtain, and information about the
      type of credentials it wants to use (i.e., symmetric or asymmetric
      cryptography).
    </t>

    <t hangText="Access Token Response (B):"><vspace blankLines="1"/>
      If the AS successfully processes the request from the client, it returns 
      an access token.  It also includes various parameters, which we call 
      "Client Information".  In addition to the response parameters defined by 
      OAuth 2.0 and the PoP token extension, we consider new kinds of response 
      parameters in <xref target="specsClientInfo"/>, including information on 
      which security protocol the client should use with the resource server(s)
      that it has just been authorized to access.  Communication security
      between client and RS may be based on pre-provisioned keys/security
      contexts or dynamically established. The RS authenticates the client via 
      the PoP token; and the client authenticates the RS via the client 
      information as described in
      <xref target="oauth2ProfilesCSP"/>.
    </t>

    <t hangText="Resource Request (C):"><vspace blankLines="1"/>
      The client interacts with the RS to request access to the protected
      resource and provides the access token.  The protocol to use
      between the client and the RS is not restricted to CoAP; HTTP, HTTP/2,
      Bluetooth Smart etc., are also possible candidates. 
      <vspace blankLines="1"/>
      Depending on the device limitations and the selected protocol this
      exchange may be split up into two phases: 

<list style="empty">
<t>(1) the client sends the access token
      to a newly defined authorization endpoint at the RS (see <xref target="oauth2ProfilesAuthzInfo"/>)
      , which conveys authorization information to the RS that may be used by the client for
      subsequent resource requests, and </t> 
<t>(2) the client makes the resource access request, using the communication security protocol and other
    client information obtained from the AS.</t>
</list> 

      <vspace blankLines="1"/>
      The RS verifies that the token is integrity protected by the AS and 
      compares the claims contained in the access token with the resource 
      request.  If the RS is online, validation can be handed over to the AS
      using token introspection (see messages D and E) over HTTP or CoAP, in
      which case the different parts of step C may be interleaved with
      introspection.
    </t>

    <t hangText="Token Introspection Request (D):"><vspace blankLines="1"/>
      A resource server may be configured to use token introspection to
      interact with the AS to obtain the most recent claims, such as scope,
      audience, validity etc. 
      associated with a specific access token.  Token introspection over
      CoAP is defined in
      <xref target="I-D.wahlstroem-ace-oauth-introspection"/> and for HTTP in 
      <xref target="I-D.ietf-oauth-introspection"/>.
      <vspace blankLines="1"/>
      Note that token introspection is an optional step and can be omitted if
      the token is self-contained and the resource server is prepared to
      perform the token validation on its own.
    </t>

    <t hangText="Token Introspection Response (E):"><vspace blankLines="1"/>
      The AS validates the token and returns the claims associated with it
      back to the RS.  The RS then uses the received claims to process the
      request to either accept or to deny it.
    </t>

    <t hangText="Protected Resource (F):"><vspace blankLines="1"/>
      If the request from the client is authorized, the RS fulfills the request 
      and returns a response with the appropriate response code.  The RS uses the
      dynamically established keys to protect the response, according to used
      communication security protocol.
    </t>
  </list>
  </t>
</section>



<!-- ***************************************************** -->

<section anchor="specsClientInfo" title="OAuth 2.0 Profiling">

  <t>
    This section describes profiles of OAuth 2.0 adjusting it to constrained
    environments for use cases where this is necessary.  Profiling for
    JSON Web Tokens (JWT) is provided in 
    <xref target="I-D.wahlstroem-ace-cbor-web-token"/>.
  </t>



<section anchor="oauth2ProfilesCSP" title="Client Information">
    
    <t>OAuth 2.0 using bearer tokens, as described in <xref
    target="RFC6749"/> and in <xref target="RFC6750"/>, 
    requires TLS for all communication interactions between client, authorization
    server, and resource server.  This is possible in the scope where OAuth 2.0
    was originally developed: web and mobile applications.  In these environments
    resources like computational power and bandwidth are not scarce and operating
    systems as well as browser platforms are pre-provisioned with trust anchors
    that enable clients to authenticate servers based on the Web PKI.  In a
    more heterogeneous IoT environment a wider range of use cases needs to be
    supported.  Therefore, this document suggests extensions to OAuth 2.0 that
    enables the AS to inform the client on how to communicate securely with a 
    RS and that allows the client to indicate communication security
    preferences to the AS.</t>
    
    <t>In the OAuth memo desfining the key distribution for
    proof-of-possession (PoP) tokens <xref
    target="I-D.ietf-oauth-pop-key-distribution"/>,  the authors suggest to
    use Uri-query parameters in order to submit the parameters of the client's
    token request.  To avoid large headers if the client uses CoAP to
    communicate with the AS, this memo specifies the following alternative for
    submitting client reuqest parameters to the AS: The client encodes the
    parameters of it's request as a CBOR map and submits that map as the
    payload of the client reuqest.  The Content-format MUST be
    application/cbor in that case.</t>
    
    <t>The OAuth memo further specifies that the AS SHALL use a JSON
    structure in the payload of the response to encode the response
    parameters.  These parameters include the authorization token, destined
    for the RS and additional information for the client, such as e.g. the PoP
    key.  We call this information "client information".  If the client is
    using CoAP to communicate with the AS the AS SHOULD use CBOR instead of
    JSON for encoding it's response.  The client can explicitly request this
    encoding by using the CoAP Accept option.</t>

    <t>The client may be a constrained device and could therefore be limited
    in the communication security protocols it supports.  It can therefore
    signal to the AS which protocols it can support for securing their 
    mutual communication.  This is done by using the "csp" parameter defined
    below in the Token Request message sent to the AS.</t>

    <t>The client and the RS might not have any prior knowledge about each 
    other, therefore the AS needs to help them to establish a security context 
    or at least a key.  The AS does this by indicating communication security 
    protocol ("csp") and additional key parameters in the client information.</t>
    
    <t>The "csp" parameter specifies how client and RS communication is going to
    be secured based on returned keys.  Currently defined values are "TLS", 
    "DTLS", "ObjectSecurity" with the encodings specified in
    <xref target="tab:cspParam"/>.  Depending on the value different
    additional parameters become mandatory.</t>
    
    <t><figure align="center" anchor="tab:cspParam"
               title="Table of 'csp' parameter value encodings for Client 
		      Information.">
      <artwork align="left"><![CDATA[
       /-----------+--------------+-----------------------\
       | Value     | Major Type   | Key                   |
       |-----------+--------------+-----------------------|
       | 0         | 0            | TLS                   |
       | 1         | 0            | DTLS                  |
       | 2         | 0            | ObjectSecurity        |
       \-----------+--------------+-----------------------/
      ]]></artwork>
    </figure></t>

    <t>CoAP specifies three security modes of DTLS: PreSharedKey, RawPublicKey
    and Certificate.  The same modes may be used with TLS.  The mode of the
    CSP to be used is negotiated in the DTLS handshake.  The AS MAY give an
    indication about the security modes supported by the RS using the "mode"
    parameter with the values specified in <xref target="tab:modeParam"/>.  If
    several modes are supported, the AS indicates this by repeating the "mode"
    parameter with different values.</t>
    
    <t><figure align="center" anchor="tab:modeParam"
               title="Table of 'mode' parameter value encodings for Client 
		      Information.">
      <artwork align="left"><![CDATA[
       /-----------+--------------+-----------------------\
       | Value     | Major Type   | Key                   |
       |-----------+--------------+-----------------------|
       | 0         | 0            | PreSharedKey (PSK)    |
       | 1         | 0            | RawPublicKey (RPK)    |
       | 2         | 0            | Certificate           |
       \-----------+--------------+-----------------------/
      ]]></artwork>
    </figure></t>

    <t>For PreSharedKey mode, the AS MUST provide the client with the 
    pre-shared key to be used with the RS.  If this mode is used together with
    PoP tokens, the PoP key MUST be a symmetric key (see section 4 of
    <xref target="I-D.ietf-oauth-pop-key-distribution"/>), the 
    client MUST use the PoP key as DTLS pre-shared key.  The AS MUST provide 
    the PoP key using the "key" parameter, specified in <xref
    target="I-D.ietf-oauth-pop-key-distribution"/>, containing either a JWK 
    <xref target="RFC7517"/> or CWK (FIXME refernce).  The client MUST use
    the "kid" parameter provided as part of the JWK/CWK as the psk_identity
    in the DTLS handshake <xref target="RFC4279"/>.</t>

    <t>If RawPublicKey mode is used, the AS MUST provide the client with the 
    RS's raw public key using the "rpk" parameter defined in the follwoing.
    This parameter MUST contain an JWK or a CWK.  A RS configured to use this
    mode together with PoP tokens MUST require client authentication in the
    DTLS handshake.  The client MUST use the raw public key bound to the PoP
    token for client authentication in DTLS.</t>    

    <t>If PoP tokens are not used, but the RS requires or supports DTLS in
    either PSK or RPK mode, then the AS MUST provide the client with the
    DTLS pre-shared key or the DTLS raw public key of the RS in the client
    information, using a parameter called "dtlskey", which SHALL contain a 
    JWK/CWK specifying the key to be used in the DTLS handshake. For symmetric
    keys the corresponding JWK/CWK MUST contain the kid parameter, which MUST
    be used as psk_identity in the DTLS handshake <xref target="RFC4279"/>.</t>
  
    <t>TLS or DTLS with certificates MAY make use of pre-established trust
    anchors or MAY be configured more tightly with additional client
    information parameters, such as x5c, x5t, or x5t#S256. An overview of
    these parameters is given below.</t>

    <t hangText="X.509 Certificate Chain (x5c)"><vspace blankLines="1"/>
    For when communication security is based on certificates this attribute
    can be used to define the server certificate or CA certificate.
    Semantics for this attribute is defined by <xref target="RFC7517"/> or
    CWK (FIXME, future reference).</t>
   
    <t hangText="X.509 Certificate Thumbprint (x5t and x5t#S256)">
    <vspace blankLines="1"/>
    For when communication security is based on certificates this attribute
    can be used to define the specific server certificate to expect or the CA
    certificate.  Semantics for this attribute is defined by JWK/CWK.</t>
    
                   
    <t>To use object security (such as OSCOAP and OSCON) requires security
    context to be established, which can be provisioned with PoP token and
    client information, or derived from that information. Object security
    specifications designed to be used with this protocol MUST specify the
    parameters that an AS has to provide to the client in order to set up
    the necessary security context.</t>
  
    <!-- If OSCON is used only the payload is protected.  This is
         setup is useful when the application has no control over the transport
         layer or when the transport layer does not support TLS, DTLS or
         CoAP at all, e.g. Bluetooth Smart.  In this case the PoP key is used
         to protect the payload from client to server could be symmetric or
         asymmetric keys.  Validation of the response differs depending on the
         key type used.  If symmetric keys are used it is derived from the PoP
         key, if an asymmetric key is used to validate server response it it is
         returned in the additional response parameter "rpk", and if certificates
         is used the certificate is referred to by x5t, x5t#S256 or x5c.  The
         encapsulation could use but is not limited to JOSE or COSE primitives
         to sign, MAC or encrypting the payload data.
    -->
</section>
  <section anchor="oauth2ProfilesCoAPAccessTokenOption"
           title="CoAP Access-Token Option">
    <t> OAuth 2.0 access tokens are usually transferred as authorisation 
    	header. CoAP has no authorisation header equivalence. This document 
    	therefor register the option Access-Token. The Access-Token option 
    	is an alternative for transferring the access token when it is smaller 
    	then 255 bytes. If token is larger the 255 bytes lager authorisation 
    	information resources MUST at the RS be user when CoAP.
    </t>
  </section>
  <section anchor="oauth2ProfilesAuthzInfo"
           title="Authorization Information Resource at the Resource Server">
    <t>A consequence of allowing the use of CoAP as web transfer protocol
      is that we cannot rely on HTTP specific mechanisms, such as
      transferring information elements in HTTP headers since those are not
      necessarily gracefully mapped to CoAP.  In case the access token is
      larger than 255 bytes it should not be sent as a CoAP option.
    </t>
    <t>For conveying authorization information to the RS we therefore
      introduce a new resource to which the PoP tokens can be sent to
      convey authorization information before the first resource request is made
      by the client.  This specification calls this resource "/authz-info"; the 
      URI may, however, vary in deployments.
    </t>
    <t>The RS needs to store the PoP token for when later
      authorising requests from the client. The RS is not mandated 
      to be able to manage multiple client at once. how the RS manages 
      clients is out of scope for this specification.
    </t>

    <section anchor="authzInfoResourceRequest" 
             title="Authorization Information Request">
    <t>The client makes a POST request to the authorisation information
      resource by sending its PoP token as request data.</t>
    <t>Client MUST send the Content-Format option indicate token format</t>
    <!-- TODO insert Content-Format -->

    </section>
      <section anchor="authzInfoResourceResponse" 
               title="Authorization Information Response">
        <t>The RS may select to not respond to save resources, 
          no response may indicate success or error the client 
          can only know by doing an access request after having 
          passed the token. If it responds it MUST respond 
          according to success or error response section</t>

      <section anchor="authzInfoResourceSuccessResponse"
               title="Success Response">
        <t>Successful responses SHOULD respond with 2.01 
          Created to indicate that a "session" for the PoP 
          Token has been created. No location path is 
          required to be returned.
        </t>
        <t>
          <figure align="center" anchor="fig:clientRSAuthzInfoSuccess"
                   title="Authorization Information Resource Success Response">
            <artwork align="left"><![CDATA[
          Resource
  Client   Server
    |         |
    |         |
A:  +-------->| Header: POST (Code=0.02)
    | POST    | Uri-Path: "/authz-info"
    |         | Content-Format: "application/cwt"
    |         | Payload: <PoP Token>
    |         |
B:  |<--------+ Header: 2.01 Created
    | 2.01    | 
    |         | 
        ]]>
            </artwork>
          </figure>
        </t>
      </section>

      <section anchor="authzInfoResourceErrorResponse"
               title="Error Response">
        <t>The resource server MUST user appropriate CoAP 
          response code to convey the error to the Client.
        </t>
        <t>
          <figure align="center" anchor="fig:clientRSAuthzInfoError"
                   title="Authorization Information Resource Error Response">
            <artwork align="left"><![CDATA[
          Resource
  Client   Server
    |         |
    |         |
A:  +-------->| Header: POST (Code=0.02)
    | POST    | Uri-Path: "/authz-info"
    |         | Content-Format: "application/cwt"
    |         | Payload: <PoP Token>
    |         |
B:  |<--------+ Header: 4.01 Unauthorized
    | 2.01    | 
    |         | 
        ]]>
            </artwork>
          </figure>
        </t>
      </section>
    </section>
  </section>

<section anchor="aifsection"
    title="Authorization Information Format">
    <t>We introduce a new claim for describing access rights with a specific 
    format, the "aif" claim.  In this memo we propose to use the compact 
    format provided by AIF  <xref target="I-D.bormann-core-ace-aif" />.  Access 
    rights may be specified as a list of URIs of resources together with allowed 
    actions (GET, POST, PUT, PATCH, or DELETE).  Other formats may be mandated
    by specific applications or requirements (e.g. specifying local conditions
    on access).
    </t>
</section>


<section anchor="oauth2ProfilesCBOR" title="CBOR Data Formats">
    <t>
        The /token resource (called "endpoint" in OAuth 2.0), defined in Section
        3.2 of <xref target="RFC6749" />, is used by the client to obtain an
        access token.  Requests sent to the /token resource use the HTTP POST 
        method and the payload includes a query component, which is formatted as
        application/x-www-form-urlencoded.  CoAP payloads cannot be formatted in
        the same way which requires the /token resource on the AS to be 
        profiled.
        <!-- FIXME: The CoAP specific information could be moved to section 4.
         -->
        
        <xref target="app:cborMappingsForOAuth2Properties" /> defines a 
        CBOR-based format for sending parameters to the /token resource.
    </t>
</section>

</section>

<!-- ***************************************************** -->

      <section anchor="options" title="Deployment Scenarios">
        <t>There is a large variety of IoT deployments, as is indicated in 
        <xref target="constraints"/>, and this section highlights common 
        variants.  This section is not normative but illustrates how the
        framework can be applied.
        </t>

        <t>For each of the deployment variants there are a number of possible
        security setups between clients, resource servers and authorization
        servers.  The main focus in the following subsections is on how 
        authorization of a client request for a resource hosted by a RS is 
        performed.  This requires us to also consider how these requests and 
        responses between the clients and the resource servers are secured. 
        </t>

        <t>The security protocols between other pairs of nodes in the
        architecture, namely client-to-AS and RS-to-AS, are not detailed in 
        these examples.  Different security protocols may be used on transport
        or application layer. 

<!--  TLS/DTLS is one option, another one is object secure CoAP
        (OSCOAP) <xref target="I-D.selander-ace-object-security"/>.  These
        protocols can be used with different kinds of keys.  For these
        interactions it is assumed in this document that keys are
        pre-established, meaning that either symmetric keys, public keys, or
        trust anchors are provisioned to the actors.
--> 
        </t>

        <t>Note: We use the CBOR
        diagnostic notation for examples of requests and responses.</t>

<!-- ************************** -->


 <!-- ************************** -->
<section anchor="bothOffline" title="Client and Resource Server are Offline">
  <t>In this scenario we consider the case where both the resource server and the client are offline, i.e., they are not connected to the AS at the time of the resource request. 
   This access procedure
  involves steps A, B, C, and F of <xref target="fig:protocolFlow"/>, but
  assumes that step A and B have been carried out during a phase when the client
  had connectivity to AS.
  </t>

  <t>Since the resource server must be able to verify the access token locally,
  self-contained access tokens must be used.</t>

<!--  <t>The access token's Audience claim ("aud")
  <xref target="I-D.ietf-oauth-pop-key-distribution"/> MUST specify an audience
  that includes the RS.  The RS MUST be able to confirm this locally, e.g.
  through a locally configured list of audience identifiers.</t>


  <section anchor="ExBothOff" title="Example">
--> 
    <t>This example shows the interactions between a client, the
    authorization server and a temperature sensor acting as a resource server.  Message
    exchanges A and B are shown in <xref target="fig:BothOffline"/>.</t>

    <t><list style="hanging">
      <t>A: The client first generates a public-private key pair used for
      communication security with the RS. <!-- Alternatively, the client may be
      pre-provisioned with a key pair, or the task outsourced to a trusted party
      such as the CAS (<xref target="I-D.ietf-ace-actors"/>).--> </t>

      <t>The client sends the POST request to /token at AS.  The request
      contains the public key of the client and the Audience parameter set to
      "tempSensorInLivingRoom", a value that the temperature sensor
      identifies itself with.  The AS evaluates the request and authorizes the
      client to access the resource.</t>

      <t>B: The AS responds with a PoP token and client information.  The PoP
      token contains the public key of the client, while the client information
      contains the public key of the RS.  For communication security
      this example uses DTLS with raw public keys between the client and the RS.</t>

      <t>Note: In this example we assume that the client knows what resource it
      wants to access, and is therefore able to request specific
      audience and scope claims for the access token.</t>
    </list></t>

    <t><figure align="center" anchor="fig:BothOffline"
               title="Token Request and Response Using Client Credentials.">
        <artwork align="left"><![CDATA[
         Authorization
  Client    Server
    |         |
    |         |
A:  +-------->| Header: POST (Code=0.02)
    | POST    | Uri-Path:"token"
    |         | Payload: <Request-Payload>
    |         |
B:  |<--------+ Header: 2.05 Content
    |         | Content-Type: application/cbor
    | 2.05    | Payload: <Response-Payload>
    |         |
        ]]></artwork>
    </figure></t>

    <t>The information contained in the Request-Payload and the
    Response-Payload is shown in <xref target="fig:bothOfflineReq"/>.

     <figure align="center" anchor="fig:bothOfflineReq"
             title="Request and Response Payload Details.">
      <artwork align="left"><![CDATA[
Request-Payload :
{
  "grant_type" : "client_credentials",
  "aud" : "tempSensorInLivingRoom",
  "client_id" : "myclient",
  "client_secret" : "qwerty"
}

Response-Payload :
{
  "access_token" : b64'SlAV32hkKG ...',
  "token_type" : "pop",
  "csp" : "DTLS",
  "key" : b64'eyJhbGciOiJSU0ExXzUi ...'
}
        ]]></artwork>
    </figure></t>

    <t>The content of the "key" parameter and the access token are shown in
    <xref target="fig:BothcborMappingValuesAsymmetricKeyFormat"/> and
    <xref target="fig:BothcborMappingValueAsymmetricCWT"/>.</t>

    <t><figure align="center"
               anchor="fig:BothcborMappingValuesAsymmetricKeyFormat"
               title="Public Key of the RS.">
        <artwork align="left"><![CDATA[
{
  "kid" : b64'c29tZSBwdWJsaWMga2V5IGlk',
  "kty" : "EC",
  "crv" : "P-256",
  "x"   : b64'MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqv7D4',
  "y"   : b64'4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM'
}
        ]]></artwork>
    </figure></t>

    <t><figure align="center"
               anchor="fig:BothcborMappingValueAsymmetricCWT"
               title="Access Token including Public Key of the Client.">
        <artwork align="left"><![CDATA[
{
  "aud" : "tempSensorInLivingRoom",
  "iat" : "1360189224",
  "cnf" : {
    "jwk" : {
      "kid" : b64'1Bg8vub9tLe1gHMzV76e8',
      "kty" : "EC",
      "crv" : "P-256",
      "x" : b64'f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU',
      "y" : b64'x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0'
    }
  }
}
        ]]></artwork>
    </figure></t>

    <t>Messages C and F are shown in
    <xref target="fig:BothOfflinePostAccessTokenAsymmetric"/> -
    <xref target="fig:BothOfflineDTLSRequestAndResponse"/>.

    <list style="hanging">
      <t>C: The client then sends the PoP token to the /authz-info resource at
      the RS.  This is a plain CoAP request, i.e. no DTLS/OSCOAP between 
      client and RS, since the token is integrity protected between AS and 
      RS.  The RS verifies that the PoP token was created by a known and trusted 
      AS, is valid, and responds to the client.  The RS caches the security 
      context together with authorization information about this client 
      contained in the PoP token.</t>

      <t>The client and resource server run the DTLS handshake using the raw 
      public keys established in step B and C.</t>

      <t>The client sends the CoAP request GET to /temperature on RS over
      DTLS.  The RS verifies that the request is authorized.</t>

      <t>F: The RS responds with a resource representation over DTLS.</t>
    </list></t>

    <t><figure align="center" anchor="fig:BothOfflinePostAccessTokenAsymmetric"
               title="Access Token provisioning to RS">
      <artwork align="left"><![CDATA[
           Resource
 Client     Server
    |         |
C:  +-------->| Header: POST (Code=0.02)
    | POST    | Uri-Path:"authz-info"
    |         | Payload: SlAV32hkKG ...
    |         |   (access token)
    |         |
    |<--------+ Header: 2.04 Changed
    | 2.04    |
    |         |
      ]]></artwork>
    </figure></t>

    <t><figure align="center" anchor="fig:BothOfflineDTLSRequestAndResponse"
               title="Resource Request and Response protected by DTLS.">
      <artwork align="left"><![CDATA[
           Resource
 Client     Server
    |         |
    |<=======>| DTLS Connection Establishment
    |         |   using Raw Public Keys
    |         |
    |         |
    +-------->| Header: GET (Code=0.01)
    | GET     | Uri-Path: "temperature"
    |         |
    |         |
    |         |
F:  |<--------+ Header: 2.05 Content
    | 2.05    | Payload: {"t":"22.7"}
    |         |
      ]]></artwork>
    </figure></t>

</section>




        <section anchor="rsOffline" title="Resource Server Offline">
          <t>In this deployment scenario we consider the case of an RS that may 
          not be able to access the AS at the time it receives an access request
          from a client.  We denote this case "RS offline", it involves steps A, 
          B, C and F of <xref target="fig:protocolFlow"/>.
          </t>
          <t>
            If the RS is offline, then it must be possible for the RS to locally
            validate the access token. This requires self-contained tokens to be 
            used.</t>
<!-- 
          <t>
            The access token's Audience claim
            ("aud") <xref target="I-D.ietf-oauth-pop-key-distribution"/>
            MUST specify an audience that includes the RS.  The RS MUST be
            able to confirm this locally e.g. through a locally configured
	    list of audience identifiers.
          </t>
--> 
          <t>
            The validity time for the token should always be chosen as short as 
	    possible to reduce the possibility that a token contains out-of-date
            authorization information. Therefore the  value for the Expiration 
            Time claim ("exp") should be set only slightly larger than the value
            for the Issuing Time claim  ("iss").  A constrained RS with means to
            reliably measure time must validate the expiration time of the 
            access token.
          </t>

            <t>The following example shows interactions between a client
            (air-conditioning control unit), an offline resource server 
            (temperature sensor)and an authorization server.  The message 
            exchanges A and B are shown in <xref target="fig:rsOffline"/>.
            </t>

            <t>
              <list style="hanging">
                <t>
                  A: The client sends the request POST to /token at AS.  The
                  request contains the Audience parameter set to
                  "tempSensor109797", a value that the temperature sensor
                  identifies itself with.  The scope the client want's the AS to
                  authorize the access token for is "owner", which means that 
                  the token can be used to both read temperature data and
                  upgrade the firmware on the RS.  The AS evaluates the request
                  and authorizes the client to access the resource.
                </t>

                <t>
                  B: The AS responds with a PoP token and client information.
                  The PoP token is wrapped in a COSE message, object secured
                  content from AS to RS.  The client information contains
                  a symmetric key.  In this case communication security between
                  C and RS is OSCOAP with an authenticated encryption
                  algorithm.  The client derives two unidirectional security
                  contexts to use with the resource request and response
                  messages.  The access token includes the claim "aif" with the
                  authorized access that an owner of the temperature device can
                  enjoy.  The "aif" claim, issued by the AS, informs the RS that
                  the owner of the access token, that can prove the possession
                  of a key is authorized to make a GET request against the
                  /tempC resource and a POST request on the /firmware resource.
                </t>
              </list>
            </t>


            <t><figure align="center" anchor="fig:rsOffline"
                       title="Token Request and Response">
                <artwork align="left"><![CDATA[

         Authorization
 Client     Server
    |         |
    |         |
A:  +-------->| Header: POST (Code=0.02)
    | POST    | Uri-Path: "token"
    |         | Payload: <Request-Payload>
    |         |
B:  |<--------+ Header: 2.05 Content
    |         | Content-Type: application/cbor
    | 2.05    | Payload: <Response-Payload>
    |         |
    |         |
            ]]>
              </artwork>
            </figure></t>

            <t>The information contained in the Request-Payload and the
            Response-Payload is shown in <xref target="fig:rsOfflineReq"/>.

              <figure align="center" anchor="fig:rsOfflineReq"
                       title="Request and Response Payload for RS offline">
                <artwork align="left"><![CDATA[

Request-Payload:
{
  "grant_type" : "client_credentials",
  "client_id" : "myclient",
  "client_secret" : "qwerty",
  "aud" : "tempSensor109797",
  "scope" : "owner"
}

Response-Payload:
{
  "access_token": b64'SlAV32hkKG ...',
  "token_type" : "pop",
  "csp" : "OSCOAP",
  "key" : b64'eyJhbGciOiJSU0ExXzUi ...'
}
                ]]></artwork>
              </figure></t>

              <t><xref target="fig:cborMappingValuesCWTsymmetricKey"/>
              shows examples of the key and the access_token parameters
	      of the Response-Payload, decoded to CBOR.</t>
 <t>
   <figure align="center" anchor="fig:cborMappingValuesCWTsymmetricKey"
           title="Access Token and symmetric key from the Response-Payload">
     <artwork align="left"><![CDATA[
access_token:
{
  "aud" : "tempSensor109797",
  "exp" : 1311281970,
  "iat" : 1311280970,
  "aif" :  [["/tempC", 0], ["/firmware", 2]],
  "cnf" : {
    "ck":b64'JDLUhTMjU2IiwiY3R5Ijoi ...'
    }
 }

key:
{
  "alg" : "AES_128_CCM_8",
  "kid" : b64'U29tZSBLZXkgSWQ',
  "k" : b64'ZoRSOrFzN_FzUA5XKMYoVHyzff5oRJxl-IXRtztJ6uE'
}
     ]]></artwork>
   </figure>
 </t>


      <t>
        Message exchanges C and F are shown in
        <xref target="fig:rsOfflinePostAccessTokenSymmetric"/> and
        <xref target="fig:rsOfflineOSCOAPRequestAndResponse"/>.
        <list style="hanging">
          <t>C: The client then sends the PoP token to the /authz-info resource
          in the RS.  This is a plain CoAP request, i.e. no DTLS/OSCOAP
          between client and RS, since the token is integrity protected 
          between AS and RS.  The RS verifies that the PoP token was created by a
          known and trusted AS, is valid, and responds to the client.  The RS 
          derives and caches the security contexts together with authorization 
          information about this client contained in the PoP token.
          </t>
          <t>
          The client sends the CoAP requests GET to /tempC on the RS using
          OSCOAP.  The RS verifies the request and that it is authorized.</t>
          <t>
          F: The RS responds with a protected status code using OSCOAP.  The
          client verifies the response.
          </t>
        </list>
      </t>

            <t><figure align="center"
                       anchor="fig:rsOfflinePostAccessTokenSymmetric"
                       title="Access Token provisioning to RS">
               <artwork align="left"><![CDATA[
           Resource
  Client    Server
    |         |
C:  +-------->| Header: POST (Code=0.02)
    | POST    | Uri-Path:"authz-info"
    |         | Payload: <Access Token>
    |         |
    |         |
    |<--------+ Header: 2.04 Changed
    | 2.04    |
    |         |
    |         |
                ]]></artwork>
              </figure>
        </t>

<t>
    <figure align="center" anchor="fig:rsOfflineOSCOAPRequestAndResponse"
            title="Resource request and response protected by OSCOAP">
        <artwork align="left"><![CDATA[
            Resource
  Client     Server
    |         |
    +-------->| Header: GET (Code=0.01)
    | GET     | Object-Security:
    |         |   (<seq>,<cid>,[Uri-Path:"tempC"],<tag>)
    |         |
F:  |<--------+ Header: 2.05 Content
    | 2.05    | Object-Security:
    |         |   (<seq>,<cid>,[22.7 C],<tag>)
    |         |
        ]]></artwork>
      </figure>

     In <xref target="fig:rsOfflineOSCOAPRequestAndResponse"/>
     the GET request contains an Object-Security option and an indication of the
     content of the COSE object: a sequence number ("seq", starting from 0), a
     context identifier ("cid") indicating the security context, the ciphertext
     containing the encrypted CoAP option identifying the resource, and the
     Message Authentication Code ("tag") which also covers the Code in the CoAP
     header.
     <vspace blankLines="1"/>
     The Object-Security ciphertext in the response [22.7 C] represents an
     encrypted temperature reading. (The COSE object is actually carried in the
     CoAP payload when possible but that is omitted to simplify notation.)
</t>
</section>




 <!-- ************************** -->

<section anchor="cOffline" title="Token Introspection with an Offline Client">

  <t>In this deployment scenario we assume that a client is not be able to 
  access the AS at the time of the access request.  Since the RS is, however, 
  connected to the back-end infrastructure it can make use of token 
  introspection.  This access procedure involves steps A-F of 
  <xref target="fig:protocolFlow"/>, but assumes steps A and B have been
  carried out during a phase when the client had connectivity to AS.
  </t>

  
  <t>Since the client is assumed to be offline, at least for a certain period of 
  time, a pre-provisioned access token has to be long-lived.  The resource 
  server may use its online connectivity to validate the access token with the
  authorization server, which is shown in the example below.</t>

<!--  <t>The access token's Audience claim ("aud")
  <xref target="I-D.ietf-oauth-pop-key-distribution"/> MUST specify an audience
  that includes the RS.</t>
-->
    <t>In the example we show the interactions between an offline client
    (key fob), a resource server (online lock), and an authorization server.  We
    assume that there is a provisioning step where the client has access to the
    AS.  This corresponds to message exchanges A and B which are shown in
    <xref target="fig:cOffline"/>.
    </t>

    <t>
      <list style="hanging">
        <t>A: The client sends the request using POST to /token at AS.  The
        request contains the Audience parameter set to  "lockOfDoor4711", a
        value the that the online door in question identifies itself with.  The
        AS generates an access token as on opaque string, which it can match to
        the specific client, a targeted audience and a symmetric key security
        context.</t>

        <t>B: The AS responds with the an access token and client information,
        the latter containing a symmetric key.
        Communication security between C and RS will be OSCOAP with 
        authenticated encryption.
        </t>
      </list>
    </t>

    <t><figure align="center" anchor="fig:cOffline"
               title="Token Request and Response using Client Credentials.">
      <artwork align="left"><![CDATA[

         Authorization
 Client     Server
    |         |
    |         |
A:  +-------->| Header: POST (Code=0.02)
    | POST    | Uri-Path:"token"
    |         | Payload: <Request-Payload>
    |         |
B:  |<--------+ Header: 2.05 Content
    |         | Content-Type: application/cbor
    | 2.05    | Payload: <Response-Payload>
    |         |
    ]]></artwork>
    </figure></t>

    <t>Authorization consent from the resource owner can be pre-configured, 
    but it can also be provided via an interactive flow with the resource 
    owner.  An example of this for the key fob case could be that the 
    resource owner has a connected car, he buys a generic key that he 
    wants to use with the car.  To authorize the key fob he connects it 
    to his computer that then provides the UI for the device.  After 
    that OAuth 2.0 implicit flow is used to authorize the key for 
    his car at the the car manufacturers AS.</t>

    <t>The information contained in the Request-Payload and the
    Response-Payload is shown in <xref target="fig:cOfflineReq"/>.

     <figure align="center" anchor="fig:cOfflineReq"
             title="Request and Response Payload for C offline">
      <artwork align="left"><![CDATA[
Request-Payload:
{
  "grant_type" : "token",
  "aud" : "lockOfDoor4711",
  "client_id" : "myclient",
}

Response-Payload:
{
  "access_token" : b64'SlAV32hkKG ...'
  "token_type" : "pop",
  "csp" : "OSCOAP",
  "key" : b64'eyJhbGciOiJSU0ExXzUi ...'
}
      ]]></artwork>
    </figure></t>

    <t>The access token in this case is just an opaque string referencing
   the authorization information at the AS.</t>

    <t><list style="hanging">
        <t>C: Next, the client POSTs the access token to the /authz-info
        resource in the RS.  This is a plain CoAP request, i.e. no 
        DTLS/OSCOAP between client and RS.  Since the token is an opaque string,
        the RS cannot verify it on its own, and thus defers to respond the 
        client with a status code until step E and only acknowledges on the CoAP
        message layer (indicated with a dashed line).</t>
    </list></t>

    <t><figure align="center" anchor="fig:cOfflinePostAccessTokenAsymmetric"
               title="Access Token provisioning to RS">
      <artwork align="left"><![CDATA[
            Resource
  Client     Server
    |         |
C:  +-------->| Header: POST (T=CON, Code=0.02
    | POST    | Token 0x2a12)
    |         | Uri-Path:"authz-info"
    |         | Payload: SlAV32hkKG ...
    |         |   (access token)
    |         |
    |<- - - - + Header: T=ACK
    |         |
      ]]></artwork>
    </figure></t>
<t>
    <list style="hanging">
        <t>D: The RS forwards the token to the /introspect
        resource on the AS.  Introspection assumes a secure connection
        between the AS and the RS, e.g. using DTLS or OSCOAP,  which
	is not detailed in this example.
        </t>

        <t>E: The AS provides the introspection response containing claims
	about the token.  This includes the confirmation key (cnf) claim
        that allows the RS to verify the client's proof of possession in
	step F.</t>

        <t>After receiving message E, the RS responds to the client's POST in
        step C with Code 2.04 (Changed), using CoAP Token 0x2a12.  This step is
        not shown in the figures.</t>

        <t><figure align="center" anchor="fig:cOfflineIntrospection"
            title="Token Introspection for C offline">
            <artwork align="left"><![CDATA[
Resource Authorization
 Server     Server
    |          |
D:  +--------->| Header: POST (Code=0.02)
    |  POST    | Uri-Path: "introspect"
    |          | Payload: <Request-Payload>
    |          |
E:  |<---------+ Header: 2.05 Content
    |  2.05    | Content-Type: application/cbor)
    |          | Payload: <Response-Payload>
    |          |
            ]]></artwork>
        </figure></t>

        <t>The information contained in the Request-Payload and the
        Response-Payload is shown in <xref target="fig:cOfflineIntroReq"/>.

        <figure align="center" anchor="fig:cOfflineIntroReq"
                title="Request and Response Payload for Introspection">
          <artwork align="left"><![CDATA[
Request-Payload:
{
  "token" : b64'SlAV32hkKG...',
  "client_id" : "myRS",
  "client_secret" : "ytrewq"
}

Response-Payload:
{
  "active" : true,
  "aud" : "lockOfDoor4711",
  "scope" : "open, close",
  "iat" : 1311280970,
  "cnf" : {
    "ck" : b64'JDLUhTMjU2IiwiY3R5Ijoi ...'
  }
}
          ]]></artwork>
        </figure></t>
      </list>
  </t>

<t>
    <list style="hanging">
        <t>
            The client sends the CoAP requests PUT 1 (= "close the lock") to
            /lock on RS using OSCOAP with a security context derived from
            the key supplied in step B.  The RS verifies the request with the
	    key supplied in step E and that it is authorized by the token
            supplied in step C.
        </t>
        <t>
            F: The RS responds with a protected status code using OSCOAP.  The
            client verifies the response.
        </t>
    </list>
</t>
        <t><figure align="center" anchor="fig:cOfflineDTLSRequestAndResponse"
            title="Resource request and response protected by OSCOAP">
            <artwork align="left"><![CDATA[
           Resource
  Client    Server
    |         |
    +-------->| Header: PUT (Code=0.03)
    | PUT     | Object-Security:
    |         |    (<seq>,<cid>,[Uri-Path:"lock", 1],<tag>)
    |         |
F:  |<--------+ Header: 2.04 Changed
    | 2.04    | Object-Security:
    |         |    (<seq>,<cid>,,<tag>)
    |         |
            ]]></artwork>
        </figure></t>

        <t>
        The Object-Security ciphertext [...] of the PUT request contains
        CoAP options that are encrypted, as well as the payload value '1' which
        is the value of PUT to the door lock.</t>

        <t> In this example there is no ciphertext of the PUT
        response, but "tag" contains a MAC which covers the request sequence
        number and context identifier as well as the Code which allows the
        Client to verify that this actuator command was well received (door
        is locked).
        </t>
    </section>


 <!-- ************************** -->

<section anchor="allOnline" title="Always-On Connectivity">
  <t>A popular deployment scenario for IoT devices is to have them always be 
  connected to the Internet so that they can be reachable to receive 
  commands.  As a continuation from the previous scenarios we assume that both 
  the client and the RS are online at the time of the access request.</t>

  <t>If the client and the resource server are online then the AS should be
  configured to issue short-lived access tokens for the resource to the
  client.  The resource server must then validate self-contained access tokens 
  or otherwise must use token introspection to obtain the up-to-date claim 
  information.  If transmission costs are high or the channel is lossy, the CWT 
  token format <xref target="I-D.wahlstroem-ace-cbor-web-token"/> may be used 
  instead of a JWT to reduce the volume of network traffic.  In terms of
  messaging this deployment scenario uses the patterns described in the 
  previous sub-sections. </t>

  <t>Note that despite the lack of connectivity constraints there may still be 
  other restrictions a deployment may face.</t>
</section>

<!-- ************************** -->

<section anchor="rsKindaOffline" title="Token-less Authorization">

    <t>In this deployment scenario we consider the case of an RS which is 
    severely energy constrained, sleeps most of the time and need to have a 
    tight messaging budget.  It is not only infeasible to access the AS at the 
    time of the access request, as in the "RS offline" case 
    <xref target="rsOffline"/>, it must be offloaded as much message 
    communication as possible.</t>

    <t>OAuth 2.0 is already an efficient protocol in terms of message exchanges
    and can be further optimized by compact encodings of tokens.  The scenario
    illustrated in this section goes beyond that and removes the access
    tokens from the protocol.  This may be considered a degenerate case of OAuth
    2.0 but it allows us to do two things:</t>
    
    <t>
        <list style="numbers">
        <t>The common case where authorization is performed by means of
            authentication fits into the same protocol framework.  Authentication
            protocol and key is specified by client information, and access 
            token is omitted. </t>
        <t>Authentication, and thereby authorization, may even be implicit,
            i.e. anyone with access to the right key is authorized to access the
            protected resource.</t>
    </list>
        </t>


    <t>In case 2., the RS does not need to receive any
    message from the client, and therefore enables offloading recurring
    resource request and response processing to a third party, such as a
    Message Broker (MB) in a publish-subscribe setting.
    </t>
    
    
    <t>
        This scenario involves steps A, B, C and F of 
        <xref target="fig:protocolFlow"/> and four parties:  a client 
        (subscriber), an offline RS (publisher),
        a trusted AS, and a MB, not necessarily trusted with
        access to the plain text publications.
        Message exchange A, B is shown in <xref target="fig:rsKindaOffline"/>.
    </t>

 <!--   <section anchor="ExRSKindaOff"
             title="Example">
 -->
 
      <t><list style="hanging">
        <t>A: The client sends the request POST to /token at AS.  The request
        contains the Audience parameter set to "birchPollenSensor301", a value
        that characterizes a certain pollen sensor resource.  The AS evaluates
        the request and authorizes the client to access the resource.</t>

        <t>B: The AS responds with an empty token and client information with a
        security context to be used by the client.  The empty token signifies 
        that authorization is performed by means of authentication using the
        communication security protocol indicated with "csp".  In this case it
        is object security of content (OSCON) i.e. protection of CoAP payload 
        only.  The security context contains the symmetric decryption key and a 
        public signature verification key of the RS.</t>
      </list></t>

      <t><figure align="center" anchor="fig:rsKindaOffline"
                 title="Token Request and Response">
        <artwork align="left"><![CDATA[
        Authorization
  Client   Server
    |         |
    |         |
A:  +-------->| Header: POST (Code=0.02)
    | POST    | Uri-Path:"token"
    |         | Payload: <Request-Payload>
    |         |
B:  |<--------+ Header: 2.05 Content
    |         | Content-Type: application/cbor
    | 2.05    | Payload: <Response-Payload>
    |         |
    |         |
        ]]>
        </artwork>
      </figure></t>

      <t>The information contained in the Request-Payload and the
      Response-Payload is shown in <xref target="fig:rsKindaOfflineReq"/>.

        <figure align="center" anchor="fig:rsKindaOfflineReq"
                       title="Request and Response Payload for RS severely
                              constrained ">
                <artwork align="left"><![CDATA[
Request-Payload :
{
  "grant_type" : "client_credentials",
  "aud" : "birchPollenSensor301",
  "client_id" : "myclient",
  "client_secret" : "qwerty"
}

Response-Payload :
{
  "access_token" : NULL,
  "token_type" : "none",
  "csp" : "OSCON",
  "key" : b64'eyJhbGciOiJSU0ExXzUi ...'
}
        ]]>
        </artwork>
      </figure></t>

      <t>The content of the "key" parameter is shown in
      <xref target="fig:rsKindaKeyParameter"/>.</t>

      <t><figure align="center" anchor="fig:rsKindaKeyParameter"
                 title="The 'key' Parameter">
        <artwork align="left"><![CDATA[
key :
{
  "alg" : "AES_128_CTR_ECDSA",
  "kid" : b64'c29tZSBvdGhlciBrZXkgaWQ';
  "k"   : b64'ZoRSOrFzN_FzUA5XKMYoVHyzff5oRJxl-IXRtztJ6uE',
  "crv" : "P-256",
  "x"   : b64'MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqv7D4',
  "y"   : b64'4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM'
}
        ]]></artwork>
      </figure></t>

<t>The RS, which sleeps most of the time, occasionally wakes up, measures the
    number birch pollens per cubic meters, publishes the measurements to the MB, 
    and then returns to sleep.  See 
    <xref target="fig:rsKindaOfflineOSCOAPRequestAndResponse"/>.
    <vspace blankLines="1"/>
   In this case the birch pollen count stopped at 270, which
   is encrypted with the symmetric key and signed with the private key of the
   RS.  The MB verifies that the message originates from RS
   using the public key of RS, that it is not a replay of an old
   measurement using the sequence number of the OSCON COSE profile, and caches
   the object secured content.  The MB does not have the secret key so is unable 
   to read the plain text measurement.</t>

<t>Message exchanges C and F are shown in
    <xref target="fig:rsKindaOfflineOSCOAPRequestAndResponse"/>.
    <list style="hanging">
        <t>
            C: Since there is no access token, the client does not address the
            /authz-info resource in the RS.  The client sends the CoAP request
            GET to /birchPollen on MB which is a plain CoAP request.
        </t>
        <t>
            F: The MB responds with the cached object secured content.
        </t>
    </list>
</t>


<t>
    <figure align="center" anchor="fig:rsKindaOfflineOSCOAPRequestAndResponse"
        title="Sensor measurement protected by COSE">
        <artwork align="left"><![CDATA[
           Message   Resource
  Client    Broker    Server
    |         |         |
    |         |<--------| Header: PUT (Code=0.02)
    |         |  PUT    | Uri-Path: "birchPollen"
    |         |         | Payload: (<seq>,<cid>,["270"],<tag>)
    |         |         |
    |         |-------->| Header: 2.04 Changed
    |         | 2.04    |
    |         |
    |         |
C:  +-------->| Header: GET (Code=0.01)
    | GET     | Uri-Path: "birchPollen"
    |         |
    |         |
F:  |<--------+ Header: 2.05 Content
    | 2.05    | Payload: (<seq>,<cid>,["270"],<tag>)
    |         |
        ]]>
        </artwork>
    </figure>
</t>
<t>
    The payload is a COSE message consisting of sequence number 'seq' stepped by
    the RS for each publication, the context identifier 'cid' in this case
    coinciding with the key identifier 'kid' of 
    <xref target="fig:rsKindaKeyParameter"/>, the encrypted measurement and the 
    signature by the RS.</t>
<t>
    Note that the same COSE message format may be used as in OSCOAP
    but that only CoAP payload is protected in this case.
</t>
<t>
    The authorization step is implicit, so while any client could request access
    the COSE object, only authorized clients have access to the symmetric key
    needed to decrypt the content.
</t>

<t>
Note that in this case the order of the message exchanges A,B and C,F could in 
principle be interchanged, i.e. the client could first request and obtain the 
protected resource in steps C,F; and after that request client information 
containing the keys decrypt and verify the message.
</t>

<!--  </section>
-->
</section>



<!-- ************************** -->

<section anchor="clientMulticast"
               title="Securing Group Communication">

<t>There are use cases that require securing communication between a (group of)
senders and a group of receivers.  One prominent example is lighting.  Often, a 
set of lighting nodes (e.g., luminaires, wall-switches, sensors) are grouped 
together and only authorized members of the group must be able read and process 
messages.  Additionally, receivers of group messages must be able to verify the 
integrity of received messages as being generated within the group.</t> 

<t>The requirements for securely communicating in such group use cases
efficiently is outlined in <xref target="I-D.somaraju-ace-multicast"/> along 
with an architectural description that aligns with the content of this
document.  The requirements for conveying the necessary identifiers to reference 
groups and also the process of commissioning devices can be accomplished using
the protocol described in this document.  For details about the lighting-unique 
use case aspects, the architecture, as well as other multicast-specific 
considerations we refer the reader to  
<xref target="I-D.somaraju-ace-multicast"/>.</t>

</section>
</section>

    <section anchor="security" title="Security Considerations">
      <t>The entire document is about security.  Security considerations
      applicable to authentication and authorization in RESTful
      environments provided in OAuth 2.0 <xref target="RFC6749"/> apply to this
      work, as well as the security considerations from
      <xref target="I-D.ietf-ace-actors"/>.  Furthermore 
      <xref target="RFC6819"/> provides additional security considerations for
      OAuth which apply to IoT deployments as well.  Finally 
      <xref target="I-D.ietf-oauth-pop-architecture"/> discusses security
      and privacy threats as well as mitigation measures for Proof-of-Possession
      tokens.</t>
    </section>

    <section anchor="iana" title="IANA Considerations">
      <t>TBD</t>
      <t>FIXME: Add registry over csp values from Figure 2</t>
    
      <section anchor="CoAPOptionNumberRegistration" title="CoAP Option Number Registration">
      	<t>
      		This section registers the "Access-Token" CoAP Option Number [RFC2046] in
      		"CoRE Parameters" sub-registry "CoAP Option Numbers" in the manner described
      		in [RFC7252].
      	</t>
        <t>
          <list style="hanging">
            <t hangText="Name"><vspace blankLines="1"/>
              Access-Token
           </t>
            <t hangText="Number"><vspace blankLines="1"/>
              TBD
            </t>
            <t hangText="Reference"><vspace blankLines="1"/>
              [draft-ietf-ace-oauth-authz]
            </t>
            <t hangText="Meaning in Request"><vspace blankLines="1"/>
              Contains an Access Token according to [draft-ietf-ace-oauth-authz] 
              containing access permissions of the client.
            </t>
            <t hangText="Meaning in Response"><vspace blankLines="1"/>
              Not used in response
            </t>
            <t hangText="Safe-to-Forward"><vspace blankLines="1"/>
              TBD
            </t>
            <t hangText="Format"><vspace blankLines="1"/>
              Based on the observer the format is perseved differently. 
              Opaque data to the cleint and CWT or referese token to the RS.
            </t>
            <t hangText="Length"><vspace blankLines="1"/>
              Less then 255 bytes
            </t>
          </list>
        </t>
      </section>
    </section>


    <section anchor="Acknowledgments" title="Acknowledgments">
        <t>We would like to thank Eve Maler for her contributions to the use of 
        OAuth 2.0 and UMA in IoT scenarios, Robert Taylor for his discussion 
        input, and Malisa Vucinic for his input on the ACRE proposal 
	<xref target="I-D.seitz-ace-core-authz"/> which was one source of 
        inspiration for this work. Finally, we would like to thank the ACE 
        working group in general for their feedback.</t>
    </section>

    <!-- Possibly a 'Contributors' section ... -->
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
      &I-D.ietf-cose-msg;

      &I-D.selander-ace-object-security;

      &I-D.ietf-oauth-pop-architecture;

      &I-D.ietf-oauth-pop-key-distribution;

      &I-D.wahlstroem-ace-oauth-introspection;

      &I-D.wahlstroem-ace-cbor-web-token;

      &I-D.ietf-oauth-introspection;

      &I-D.bormann-core-ace-aif;

      &RFC2119;

      &RFC4279;

      &RFC6347;

      &RFC7252;
           
      &RFC7517;

    </references>

    <references title="Informative References">
      <!-- Here we use entities that we defined at the beginning. -->
      <!-- &I-D.ietf-ace-usecases;
      &RFC7250;

-->

      &I-D.somaraju-ace-multicast; 
   
      &I-D.seitz-ace-core-authz;

      &I-D.ietf-ace-actors;

      &I-D.ietf-core-block;

      &RFC4680;

      &RFC4949;

      &RFC5246;

      &RFC6690;

      &RFC6749;

      &RFC6750;
      
      &RFC6819;

      &RFC7049;

      &RFC7159;

      &RFC7228;

      &RFC7231;

      &RFC7519;

    </references>

    <section title="Design Justification" anchor="constraints">

     <t>This section provides further insight into the design decisions
     of the solution documented in this document.  <xref target="overview"/>
     lists several building blocks and briefly summarizes their importance.
     The justification for offering some of those building blocks, as opposed
     to using OAuth 2.0 as is, is given below.</t>

     <t>Common IoT constraints are:

        <list style="hanging">

          <t hangText="Low Power Radio:"><vspace blankLines="1"/>
          Many IoT devices are equipped with a small battery which needs
          to last for a long time.  For many constrained wireless devices the
          highest energy cost is associated to transmitting or receiving
          messages.  It is therefore important to keep the total communication
          overhead low, including minimizing the number and size of messages
          sent and received, which has an impact of choice on the message format
          and protocol.  By using CoAP over UDP, and CBOR encoded messages
          some of these aspects are addressed.  Security protocols contribute
          to the communication overhead and can in some cases be
          optimized.  For example authentication and key establishment may in
          certain cases where security requirements so allows be replaced by
          provisioning of security context by a trusted third party, using
          transport or application layer security.
          </t>

          <t hangText="Low CPU Speed:"><vspace blankLines="1"/>
          Some IoT devices are equipped with processors that are significantly
          slower than those found in most current devices on the Internet.
          This typically has implications on what timely cryptographic
          operations a device is capable to perform, which in turn impacts
          e.g. protocol latency.  Symmetric key cryptography may be used
          instead of the computationally more expensive public key cryptography
          where the security requirements so allows, but this may also require
          support for trusted third party assisted secret key establishment
          using transport or application layer security.
          </t>

          <t hangText="Small Amount of Memory:"> <vspace blankLines="1"/>
          Microcontrollers embedded in IoT devices are often equipped with
          small amount of RAM and flash memory, which places limitations what
          kind of processing can be performed and how much code can be put on
          those devices.  To reduce code size fewer and smaller protocol
          implementations can be put on the firmware of such a device.  In
          this case, CoAP may be used instead of HTTP,  symmetric key
          cryptography instead of public key cryptography, and CBOR instead of
          JSON.  Authentication and key establishment protocol, e.g. the DTLS
          handshake,  in comparison with assisted key establishment also has
          an impact on memory and code.
          </t>

          <t hangText="User Interface Limitations:"> <vspace blankLines="1"/>
          Protecting access to resources is both an important security as well
          as privacy feature.  End users and enterprise customers do not want
          to give access to the data collected by their IoT device or to
          functions it may offer to third parties.  Since the classical
          approach of requesting permissions from end users via a rich user
          interface does not work in many IoT deployment scenarios these
          functions need to be delegated to user controlled devices that are
          better suitable for such tasks, such as smart phones and tablets.</t>

          <t hangText="Communication Constraints:"> <vspace blankLines="1"/>
          In certain constrained settings an IoT device may not be able to
          communicate with a given device at all times.  Devices may be
          sleeping, or just disconnected from the Internet because of general
          lack of connectivity in the area, for cost reasons, or for security
          reasons, e.g. to avoid an entry point for Denial-of-Service attacks.

          <vspace blankLines="1"/>
          The communication interactions this framework builds upon (as shown
          graphically in <xref target="fig:protocolFlow"/>) may be accomplished
          using a variety of different protocols, and not all parts of the
          message flow are used in all applications due to the communication
          constraints.  While we envision deployments to make use of CoAP we
          explicitly want to support HTTP, HTTP/2 or specific protocols, such
          as Bluetooth Smart communication, which does not necessarily use
          IP.  The latter raises the  need for application layer security over
          the various interfaces.
          </t>

        </list>
      </t>

    </section>

    <section anchor="app:rolesAndResponsibilities" title="Roles and
      Responsibilites -- a Checklist">
      <t><list style="hanging">
	<t hangText="Resource Owner">
	  <list style="symbols">
	    <t>Make sure that the RS is registered at the AS.</t>
	    <t>Make sure that clients can discover the AS which is in charge
	    of the RS.</t>
	    <t>Make sure that the AS has the necessary, up-to-date, access 
	    control policies for the RS.</t>
	  </list>
	</t>
	<t hangText="Requesting Party">
	  <list style="symbols">
	    <t>Make sure that the client is provisioned the necessary
	    credentials to authenticate to the AS.</t>
	    <t>Make sure that the client is configured to follow the security
	    requirements of the Requesting Party, when issuing requests
	    (e.g. minimum communication security requirements, trust
	    anchors).</t>
	    <t>Register the client at the AS.</t>
          </list>
        </t>
	<t hangText="Authorization Server">
	  <list style="symbols">
	    <t>Register RS and manage corresponding security contexts.</t>
            <t>Register clients and including authentication credentials.</t>
	    <t>Allow Resource Onwers to configure and update access control
	    policies related to their registered RS'</t>
	    <t>Expose a service that allows clients to request tokens.</t>
            <t>Authenticate clients that whish to request a token.</t>
	    <t>Process a token requests against the authorization
	    policies configured for the RS.</t>
	    <t>Expose a service that allows RS's to submit token introspection
	    requests.</t>
	    <t>Authenticate RS's that whish to get an introspection response.</t>
	    <t>Process token introspection requests.</t>
	    <t>Optionally: Handle token revokation.</t>
          </list>
	</t>
        <t hangText="Client">
	  <list style="symbols">
	    <t>Discover the AS in charge of the RS that is to be targeted with
	    a request.</t>
            <t>Submit the token request (A).
	      <list style="symbols">
		<t>Authenticate towards the AS.</t>
		<t>Specify which RS, which resource(s), and which action(s)
		the request(s) will target.</t>
		<t>Specify preferences for communication security</t>
		<t>If raw public key (rpk) is used, make sure the AS has the
		right rpk for this client.</t>
	      </list>
	    </t>
	    <t>Process the access token and client information (B)
	       <list style="symbols">
		<t>Check that the token has the right format (e.g. CWT).</t>
		<t>Check that the client information provides the necessary
		security parameters (e.g. PoP key, information on
		communication security protocols supported by the RS).</t>
	      </list>
	    </t>
	    <t>Send the token and request to the RS (C)
	      <list style="symbols">
		<t>Authenticate towards the RS (this could coincide with the
		proof of possession process).</t>
		<t>Transmit the token as specified by the AS (default is to an
		authorization information resource, alternative options are as
		a CoAP option or in the DTLS handshake).</t>
		<t>Perform the proof-of-possession procedure as specified for
		the type of used token (this may already have been taken care
		of through the authentication procedure).</t>
	      </list>
	    </t>
	    <t>Process the RS response (F)
	    requirements of the Requesting Party, when issuing requests
	    (e.g. minimum communication security requirements, trust
	    anchors).</t>
	    <t>Register the client at the AS.</t>
          </list>
	</t>
	<t hangText="Resource Server">
	  <list style="symbols">
	    <t>Expose a way to submit authorization tokens.</t>
            <t>Process an authorization token.
	      <list style="symbols">
		<t>Verify the token is from the right AS.</t>
		<t>Verify that the token applies to this RS.</t>
		<t>Check that the token has not expired (if the token provides
		expiration information).</t>
		<t>Check the token's integrity.</t>
		<t>Store the token so that it can be retrieved in the context
		of a matching request.</t>
	      </list>
	    </t>
	    <t>Process a request.
	     <list style="symbols">
	        <t>Set up communication security with the client.</t>
		<t>Authenticate the client.</t>
		<t>Match the client against existing tokens.</t>
		<t>Check that tokens beloinging to the client actually
		authorize the requested action.</t>
		<t>Optionally: Check that the matching tokens are still valid (if this is
		possible.</t>
	      </list>
	    </t>
	    <t>Send a response following the agreed upon communication security.</t>
          </list>
	</t>
      </list></t>
    </section>

    <section anchor="app:optionsOptimizations" title="Optimizations">
      <t>This section sketches some potential optimizations to the presented
      solution.</t>

      <t><list style="hanging">
      <t hangText="Access token in DTLS handshake"><vspace blankLines="1"/>
      In the case of CSP=DTLS/TLS, the access token provisoning exchange in
      step C of the protocol may be embedded in the security
      handshake.  Different solutions are possible, where one standardized
      method would be the use of the TLS supplemental data extension
      <xref target="RFC4680"/> for transferring the access token.</t>

     <t hangText="Reference token and introspection"><vspace blankLines="1"/>
     In case of introspection it may be beneficial to utilize access tokens
     which are not self-contained (also known as "reference tokens")
     that are used to lookup detailed information about the authorization.
     The RS uses the introspection message exchange not only for validating
     token claims, but also for obtaining claims that potentially were not
     known at the time when the access token was issued.

     <vspace blankLines="1"/>A reference token can be made much more compact
     than a self-contained token, since it does not need to contain any of 
     claims that it represents.  This could be very useful in particular if the 
     client is constrained and offline most of the time.</t>

     <t hangText="Reference token in CoAP option"><vspace blankLines="1"/>
     While large access tokens must be sent in CoAP payload, if the access
     token is known to be of a certain limited size, for example in the case of
     a reference token, then it would be favorable to combine the access token
     provisioning request with the resource request to the RS.

     <vspace blankLines="1"/>One way to achieve this is to define a new CoAP
     option for carrying reference tokens, called "Ref-Token" as shown in the
     example in <xref target="fig:ref-token-optimization"/>.</t>

      <t><figure align="center" anchor="fig:ref-token-optimization"
                 title="Reference Token in CoAP Option">
         <artwork align="left"><![CDATA[
           Resource
  Client    Server
    |         |
C:  +-------->| Header: PUT (Code=0.02)
    | PUT     | Ref-Token:SlAV32hkKG
    |         | Object-Security:
    |         |    <seq>,<cid>,[Uri-Path:"lock", 1],<tag>)
    |         |
    .         .
    .         .
    .         .
    |         |
F:  |<--------+ Header: 2.04 Changed
    | 2.04    | Object-Security:
    |         |    (<seq>,<cid>,,<tag>)
    |         |
                    ]]></artwork>
                </figure>
            </t>
        </list>
      </t>
    </section>

    <section anchor="app:cborMappingsForOAuth2Properties"
      title="CoAP and CBOR profiles for OAuth 2.0">

      <t>
        Many IoT devices can support OAuth 2.0 without any additional
        extensions, but for certain constrained settings additional profiling
        is needed.  In this appendix we define CoAP resources for the HTTP based
        token and introspection endpoints used in vanilla OAuth 2.0.  We also
        define a CBOR alternative to the JSON and form based POST structures
        used in HTTP.
      </t>

    <section anchor="tokenResource"
       title="Profile for Token resource">

       <t>The token resource is used by the client to obtain an access token by
       presenting its authorization grant or client credentials to the /token
       resource the AS.</t>

         <section anchor="tokenResourceRequest"
           title="Token Request">
           <t>The client makes a request to the token
             resource by sending a CBOR structure with the following
             attributes.</t>
           <t>
             <list style="hanging">
               <t hangText="grant_type:"><vspace blankLines="1"/>
                REQUIRED.  The grant type, "code",  "client_credentials",
                "password" or others.
               </t>
               <t hangText="client_id:"><vspace blankLines="1"/>
               OPTIONAL.  The client identifier issued to the holder of the
               token (client or RS) during the registration process.
               </t>
               <t hangText="client_secret:"><vspace blankLines="1"/>
               OPTIONAL.  The client secret.
               </t>
               <t hangText="scope:"><vspace blankLines="1"/>
               OPTIONAL.  The scope of the access request as described by
               <xref target="oauth2Overview" />.
               </t>
               <t hangText="aud:"><vspace blankLines="1"/>
                OPTIONAL.  Service-specific string identifier
                 or list of string identifiers representing the intended
                 audience for this token, as defined in 
                 <xref target="I-D.wahlstroem-ace-cbor-web-token"/>.
               </t>
               <t hangText="alg:"><vspace blankLines="1"/>OPTIONAL.  The value
               in the 'alg' parameter together with value from the
               'token_type' parameter allow the client to indicate the supported
               algorithms for a given token type.
               </t>
               <t hangText="key:"><vspace blankLines="1"/>
                OPTIONAL.  This field contains information
                 about the public key the client would like to bind to the
                 access token in the COSE Key Structure format.
               </t>
             </list>
           </t>

           <t>The parameters defined above use the following CBOR major
           types.</t>

           <t>
             <figure align="center" anchor="fig:cborTokenMappingRequest"
               title="CBOR mappings used in token requests">
               <artwork align="left"><![CDATA[
     /-----------+--------------+-----------------------\
     | Value     | Major Type   | Key                   |
     |-----------+--------------+-----------------------|
     | 0         | 0            | grant_type            |
     | 1         | 0            | client_id             |
     | 2         | 0            | client_secret         |
     | 3         | 0            | scope                 |
     | 4         | 0            | aud                   |
     | 5         | 0            | alg                   |
     | 6         | 0            | key                   |
     \-----------+--------------+-----------------------/
               ]]></artwork>
             </figure>
           </t>
         </section>

         <section anchor="tokenResourceResponse"
           title="Token Response">

           <t>The AS responds by sending a CBOR structure with the following
             attributes.</t>

           <t>
             <list style="hanging">

               <t hangText="access_token:"><vspace blankLines="1"/>
                 REQUIRED.  The access token issued by the authorization server.
               </t>

               <t hangText="token_type:"><vspace blankLines="1"/>
                 REQUIRED.  The type of the token issued. "pop" is recommended.
               </t>

              <t hangText="key:"><vspace blankLines="1"/>
                REQUIRED, if symmetric key cryptography is used.  A COSE Key
                Structure containing the symmetric proof of possession key.  The
                members of the structure can be found in section 7.1 of
                <xref target="I-D.ietf-cose-msg" />.
              </t>

              <t hangText="csp:"><vspace blankLines="1"/>
                REQUIRED.  Information on what communication protocol to use
                in the communication between the client and the RS.  Details on
                possible values can be found in
                <xref target="oauth2ProfilesCSP" />.
              </t>

               <t hangText="scope:"><vspace blankLines="1"/>
                 OPTIONAL, if identical to the scope requested by the client;
                 otherwise, REQUIRED.
               </t>

               <t hangText="alg:"><vspace blankLines="1"/>
                 OPTIONAL.  The 'alg' parameter provides further information
                 about the algorithm, such as whether a symmetric or an
                 asymmetric crypto-system is used.
               </t>

             </list>
           </t>

           <t>The parameters defined above use the following CBOR major 
           types.</t>

            <t>
              <figure align="center" anchor="fig:cborTokenMappingResponse"
                title="CBOR mappings used in token responses">
                <artwork align="left"><![CDATA[
      /-----------+--------------+-----------------------\
      | Value     | Major Type   | Key                   |
      |-----------+--------------+-----------------------|
      | 0         | 0            | access_token          |
      | 1         | 0            | token_type            |
      | 2         | 0            | key                   |
      | 3         | 0            | csp                   |
      | 4         | 0            | scope                 |
      | 5         | 0            | alg                   |
      \-----------+--------------+-----------------------/
                ]]></artwork>
              </figure>
            </t>
         </section>

<!-- 
         <section anchor="tokenResourceExample"
           title="Example">
           <t>
             An example of a token request done using CoAP and CBOR
             can be found in <xref target="ExCOff" />
           </t>
         </section>
--> 

      </section>



      <section anchor="introspectionResource"
         title="CoAP Profile for OAuth Introspection">

         <t>This section defines a way for a holder of access tokens, mainly
           clients and RS's, to get metadata like validity status, claims and
           scopes found in access token.  The OAuth Token Introspection
           specification <xref target="I-D.ietf-oauth-introspection"/> defines
           a way to validate the token using HTTP POST or HTTP GET.
           This document reuses the work done in the OAuth Token Introspection
           and defines a mapping of the request and response to CoAP
           <xref target="RFC7252"/> to be used by constrained devices.</t>

           <section anchor="introspectionResourceRequest"
             title="Introspection Request">
             <t>The token holder makes a request to the Introspection CoAP
               resource by sending a CBOR structure with the following
               attributes.</t>
             <t>
               <list style="hanging">
                 <t hangText="token:"><vspace blankLines="1"/>
                 REQUIRED.  The string value of the token.
                 </t>
                 <t hangText="resource_id:"><vspace blankLines="1"/>
                  OPTIONAL.  A service-specific string identifying the resource
                  that the client doing the introspection is asking about.
                 </t>
                 <t hangText="client_id:"><vspace blankLines="1"/>
                   OPTIONAL.  The client identifier issued to the holder of the 
                   token (client or RS) during the registration process.
                 </t>
                 <t hangText="client_secret:"><vspace blankLines="1"/>
                 OPTIONAL.  The client secret.
                 </t>
               </list>
             </t>

             <t>The parameters defined above use the following CBOR major 
             types:</t>

             <t>
               <figure align="center" anchor="fig:cborIntrospectionReq"
                 title="CBOR Mappings to Token Introspection Request Parameters.">
                 <artwork align="left"><![CDATA[
       /-----------+--------------+-----------------------\
       | Value     | Major Type   | Key                   |
       |-----------+--------------+-----------------------|
       | 0         | 0            | token                 |
       | 1         | 0            | resource_id           |
       | 2         | 0            | client_id             |
       | 3         | 0            | client_secret         |
       \-----------+--------------+-----------------------/
                 ]]></artwork>
               </figure>
             </t>
<!-- 
             <t>FIXME: Fix better mappings to CBOR.</t>
--> 
           </section>

           <section anchor="introspectionResourceResponse"
             title="Introspection Response">

              <t>If the introspection request is valid and authorized, the
              authorization server returns a CoAP message with the response 
              encoded as a CBOR structure in the payload of the message.  If the
              request failed client authentication or is invalid, the
              authorization server returns an error response using the CoAP 4.00 
              'Bad Request' response code.</t>

             <t>The JSON structure in the payload response includes the top-level
               members defined in Section 2.2 in the OAuth Token Introspection
               specification <xref target="I-D.ietf-oauth-introspection"/>.
               It is RECOMMENDED to only return the 'active' attribute 
               considering constrained nature of CoAP client and server 
               networks.</t>

             <t>Introspection responses in CBOR use the following
               mappings:</t>

             <t>
               <list style="hanging">

                 <t hangText="active:"><vspace blankLines="1"/>
                   REQUIRED.  The active key is an indicator of whether or not
                   the presented token is currently active.  The specifics of a
                   token's "active" state will vary depending on the 
                   implementation of the authorization server, and the
                   information it keeps about its tokens, but a "true" value
                   return for the "active" property will generally indicate that 
                   a given token has been issued by this authorization server, 
                   has not been revoked by the resource owner, and is within its
                   given time window of validity (e.g., after its
                   issuance time and before its expiration time).
                 </t>

                 <t hangText="scope:"><vspace blankLines="1"/>
                   OPTIONAL.  A string containing a space-separated list of
                  scopes associated with this token, in the format described in
                  Section 3.3 of OAuth 2.0 <xref target="RFC6749" />.
                 </t>

                <t hangText="client_id:"><vspace blankLines="1"/>
                  OPTIONAL.  Client identifier for the client that
                  requested this token.
                </t>

                <t hangText="username:"><vspace blankLines="1"/>
                  OPTIONAL.  Human-readable identifier for the resource owner 
                  who authorized this token.
                </t>

                <t hangText="token_type:"><vspace blankLines="1"/>
                  OPTIONAL.  Type of the token as defined in Section 5.1 of
                  OAuth 2.0 <xref target="RFC6749" /> or PoP token.
                </t>

                <t hangText="exp:"><vspace blankLines="1"/>
                  OPTIONAL.  Integer timestamp, measured in the number of 
                  seconds since January 1 1970 UTC, indicating when this token 
                  will expire, as defined in CWT 
                  <xref target="I-D.wahlstroem-ace-cbor-web-token" />.
                </t>

                <t hangText="iat:"><vspace blankLines="1"/>
                  OPTIONAL.  Integer timestamp, measured in the number of
                  seconds since January 1 1970 UTC, indicating when this token
                  will expire, as defined in CWT 
                  <xref target="I-D.wahlstroem-ace-cbor-web-token" />.
                </t>

                <t hangText="nbf:"><vspace blankLines="1"/>
                  OPTIONAL.  Integer timestamp, measured in the number of
                  seconds since January 1 1970 UTC, indicating when this token 
                  will expire, as defined in CWT 
                  <xref target="I-D.wahlstroem-ace-cbor-web-token" />.
                </t>

                <t hangText="sub:"><vspace blankLines="1"/>
                  OPTIONAL.  Subject of the token, as defined in CWT
                  <xref target="I-D.wahlstroem-ace-cbor-web-token" />.  Usually 
                  a machine-readable identifier of the resource owner who 
                  authorized this token.
                </t>

                <t hangText="aud:"><vspace blankLines="1"/>
                  OPTIONAL.  Service-specific string identifier or list of
                  string identifiers representing the intended audience for this
                  token, as defined in CWT 
                  <xref target="I-D.wahlstroem-ace-cbor-web-token" />.
                </t>

                <t hangText="iss:"><vspace blankLines="1"/>
                  OPTIONAL.  String representing the issuer of this token, as
                  defined in CWT 
                  <xref target="I-D.wahlstroem-ace-cbor-web-token" />.
                </t>

                <t hangText="cti:"><vspace blankLines="1"/>
                  OPTIONAL.  String identifier for the token, as defined in CWT
                  <xref target="I-D.wahlstroem-ace-cbor-web-token" />
                </t>

               </list>
             </t>

             <t>The parameters defined above use the following CBOR major 
             types:</t>

              <t>
                <figure align="center" anchor="fig:cborIntrospectionResp"
                  title="CBOR Mappings to Token Introspection Response Parameters.">
                  <artwork align="left"><![CDATA[
/-----------+--------------+-----------------------\
| Value     | Major Type   | Key                   |
|-----------+--------------+-----------------------|
| 0         | 0            | active                |
| 1         | 0            | scopes                |
| 2         | 0            | client_id             |
| 3         | 0            | username              |
| 4         | 0            | token_type            |
| 5         | 0            | exp                   |
| 6         | 0            | iat                   |
| 7         | 0            | nbf                   |
| 8         | 0            | sub                   |
| 9         | 0            | aud                   |
| 10        | 0            | iss                   |
| 11        | 0            | cti                   |
\-----------+--------------+-----------------------/
                  ]]></artwork>
                </figure>
              </t>
<!-- 
              <t>FIXME: Fix better mappings to CBOR.</t>
--> 
           </section>

<!-- 
           <section anchor="introspectionResourceExample"
             title="Example">
             <t>
               An example of a introspection request done using CoAP and CBOR
               can be found in <xref target="ExCOff" />
             </t>
           </section>
--> 
        </section>



    </section>
  </back>
</rfc>
