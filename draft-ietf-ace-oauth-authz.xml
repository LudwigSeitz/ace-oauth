<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced.
     An alternate method (rfc include) is described in the references. -->

<!ENTITY RFC2119 SYSTEM
"http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC4949 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4949.xml">
<!ENTITY RFC5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY RFC6347 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6347.xml">
<!ENTITY RFC6690 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6690.xml">
<!ENTITY RFC6749 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6749.xml">
<!ENTITY RFC6819 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6819.xml">
<!ENTITY RFC7049 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7049.xml">
<!ENTITY RFC7159 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7159.xml">
<!ENTITY RFC7228 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7228.xml">
<!ENTITY RFC7231 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7231.xml">
<!ENTITY RFC7252 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7252.xml">
<!ENTITY RFC7519 SYSTEM
"http://xml.resource.org/public/rfc/bibxml/reference.RFC.7519.xml">
<!ENTITY RFC7591 SYSTEM
"http://xml.resource.org/public/rfc/bibxml/reference.RFC.7591.xml">
<!ENTITY RFC7662 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7662.xml">
<!ENTITY RFC7744 SYSTEM
"http://xml.resource.org/public/rfc/bibxml/reference.RFC.7744.xml">
<!ENTITY RFC7800 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7800.xml">
<!ENTITY I-D.ietf-ace-actors SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-ace-actors.xml">
<!ENTITY I-D.ietf-cose-msg SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-cose-msg.xml">
<!ENTITY I-D.selander-ace-object-security SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.selander-ace-object-security.xml">
<!ENTITY I-D.ietf-ace-cbor-web-token SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-ace-cbor-web-token.xml">
<!ENTITY I-D.ietf-core-block SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-core-block.xml">
<!ENTITY I-D.seitz-ace-core-authz SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.seitz-ace-core-authz.xml">
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-ietf-ace-oauth-authz-02" ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN"
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
        full title is longer than 39 characters -->

<title abbrev="ACE">Authentication and Authorization for Constrained Environments (ACE)</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Ludwig Seitz" initials="L." surname="Seitz">
      <organization>SICS</organization>

      <address>
        <postal>
          <street>Scheelevaegen 17</street>
          <code>223 70</code> <city>Lund</city>
          <country>SWEDEN</country>
        </postal>
        <email>ludwig@sics.se</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Goeran Selander" initials="G." surname="Selander">
      <organization>Ericsson</organization>

      <address>
        <postal>
          <street>Faroegatan 6</street>
          <code>164 80</code> <city>Kista</city>
          <country>SWEDEN</country>
        </postal>
        <email>goran.selander@ericsson.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Erik Wahlstroem" initials="E." surname="Wahlstroem">
      <organization></organization>

      <address>
        <postal>
          <street></street>
          <code></code> <city></city>
          <country>Sweden</country>
        </postal>
        <email>erik@wahlstromtekniska.se</email>
      </address>
    </author>

    <author fullname="Samuel Erdtman" initials="S." surname="Erdtman">
      <organization>Spotify AB</organization>

      <address>
        <postal>
          <street>Birger Jarlsgatan 61, 4tr</street>
          <code>113 56</code> <city>Stockholm</city>
          <country>Sweden</country>
        </postal>
        <email>erdtman@spotify.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Hannes Tschofenig" initials="H." surname="Tschofenig">
      <organization>ARM Ltd.</organization>

      <address>
        <postal>
          <street></street>
          <code>6060</code> <city>Hall in Tirol</city>
          <country>Austria</country>
        </postal>
        <email>Hannes.Tschofenig@arm.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>
    <date year="2016" />



    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
         in the current day for you. If only the current year is specified, xml2rfc will fill
	 in the current day and month for you. If the year is not the current one, it is
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to
	 specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>Security</area>

    <workgroup>ACE Working Group</workgroup>

    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.
	 If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>CoAP, OAuth 2.0, Access Control, Authorization, Internet of Things</keyword>

    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t>This specification defines the ACE framework for authentication and authorization
        in Internet of Things (IoT) deployments. The ACE framework is based on
        a set of building blocks including OAuth 2.0 and CoAP, thus making a well-known and
      widely used authorization solution suitable for IoT devices.  Existing specifications
      are used where possible, but where the limitations of IoT devices require it,
      profiles and extensions are provided.
      </t>
    </abstract>
  </front>

<middle>

<!-- ***************************************************** -->

<section anchor="intro" title="Introduction">

   <t>Authorization is the process for granting approval to an entity to
   access a resource <xref target="RFC4949"/>. The authorization task itself can
   best be described as granting access to a
   requesting client, for a resource hosted on a device, the resource
   server (RS).  This exchange is mediated by one or multiple
   authorization servers (AS). Managing authorization for
   a large number of devices and users is a complex task. </t>

   <t>While prior work on authorization solutions for the Web and for the mobile
   environment also applies to the IoT environment many IoT devices are constrained,
   for example in terms of processing capabilities, available memory, etc.
   For web applications on constrained nodes this specification makes use of
   CoAP <xref target="RFC7252"/>.</t>

   <t>A detailed treatment of constraints can be found in <xref target="RFC7228"/>, and the
   different IoT deployments present a
   continuous range of device and network capabilities.  Taking energy
   consumption as an example: At one end there are energy-harvesting or
   battery powered devices which have a tight power budget, on the other
   end there are mains-powered devices, and all levels in between.</t>

   <t>Hence, IoT devices may be very different in terms of available processing
   and message exchange capabilities and there is a need to support many
     different authorization use cases <xref target="RFC7744"/>.</t>

   <t>This specification describes a framework for authentication and authorization
   in constrained environments (ACE) built on re-use of OAuth 2.0
   <xref target="RFC6749"/>, thereby extending authorization to Internet of Things
   devices.  This specification contains the necessary building blocks
   for adjusting OAuth 2.0 to IoT environments.</t>

   <t>More detailed, interoperable specifications can be found in profiles.
   Implementations may claim conformance with a specific profile,
   whereby implementations utilizing the same profile interoperate while
   implementations of different profiles are not expected to be interoperable.
   Some devices, such as mobile phones and tablets, may implement multiple
   profiles and will therefore be able to interact with a wider range of low end devices.
   </t>

</section>

<!-- ***************************************************** -->

<section anchor="terminology" title="Terminology">
  <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in
this document are to be interpreted as described in <xref
target="RFC2119"/>.  </t>

  <t>Certain security-related terms such as "authentication",
"authorization", "confidentiality", "(data) integrity", "message
authentication code", and "verify" are taken from <xref
target="RFC4949"/>.
  </t>

  <t>Since we describe exchanges as RESTful protocol interactions HTTP
<xref target="RFC7231"/> offers useful terminology.
  </t>

  <t>Terminology for entities in the architecture is defined in OAuth
2.0 <xref target="RFC6749"/> and <xref target="I-D.ietf-ace-actors"/>,
such as client (C), resource server (RS), and authorization server
(AS).</t>

<t>Note that the term "endpoint" is used here following its OAuth
definition, which is to denote resources such as /token and
/introspect at the AS and /authz-info at the RS.  The CoAP <xref
target="RFC7252"/> definition, which is "An entity participating in the CoAP protocol" is not used in this memo.</t>

<t>
Since this specification focuses on the problem of access control to resources,
we simplify the actors by assuming that the client authorization server (CAS)
functionality is not stand-alone but subsumed by either the authorization
server or the client (see section 2.2 in <xref target="I-D.ietf-ace-actors"/>).
</t>

</section>

<!-- ***************************************************** -->

<section anchor="overview" title="Overview">

  <t>This specification defines the ACE framework for authorization in the Internet
      of Things environment. It consists of a set of building blocks.</t>

  <t>
  The basic block is the OAuth 2.0 <xref target="RFC6749"/>
  framework, which enjoys widespread deployment.  Many IoT devices can support
  OAuth 2.0 without any additional extensions, but for certain constrained
  settings additional profiling is needed.
  </t>

  <t>Another building block is the lightweight web transfer protocol CoAP
  <xref target="RFC7252"/> for those communication environments where HTTP is
  not appropriate.  CoAP typically runs on top of UDP which further reduces
  overhead and message exchanges. While this specification defines extensions
for the use of OAuth over CoAP, we do envision further underlying protocols to be
supported in the future, such as MQTT or QUIC.</t>

  <t>A third building block is CBOR <xref target="RFC7049"/> for encodings
  where JSON <xref target="RFC7159"/> is not sufficiently compact.  CBOR is a
  binary encoding designed for small code and message size, which may be used for encoding of
  self contained tokens, and also for encoding CoAP POST parameters and CoAP responses.
  </t>

  <t>A fourth building block is the compact CBOR-based secure message format
  COSE <xref target="I-D.ietf-cose-msg"/>, which enables application layer
  security as an alternative or complement to transport layer security (DTLS
    <xref target="RFC6347"/> or TLS <xref target="RFC5246"/>). COSE is used to
    secure self contained tokens such as proof-of-possession (PoP) tokens,
    which is an extension to the OAuth access tokens, and "client tokens" which
    are defined in this framework (see <xref target="clientToken"/>). The
    default access token format is defined in CBOR web token (CWT)
    <xref target="I-D.ietf-ace-cbor-web-token"/>.
    Application layer security for CoAP using COSE can be provided with OSCOAP
    <xref target="I-D.selander-ace-object-security"/>.</t>

  <t>With the building blocks listed above, solutions satisfying various
  IoT device and network constraints are possible.  A list of constraints is
  described in detail in RFC 7228 <xref target="RFC7228"/> and a description
  of how the building blocks mentioned above relate to the various constraints
  can be found in <xref target="constraints"/>.</t>

  <t>Luckily, not every IoT device suffers from all constraints.  The ACE
  framework nevertheless takes all these aspects into account and allows
  several different deployment variants to co-exist rather than mandating a
  one-size-fits-all solution.  We believe this is important to cover the wide
  range of possible interworking use cases and the different requirements from
  a security point of view.  Once IoT deployments mature, popular deployment
  variants will be documented in form of ACE profiles.</t>

  <t>In the subsections below we provide further details about the different
  building blocks.</t>

  <section anchor="oauth2Overview" title="OAuth 2.0">
    <t>The OAuth 2.0 authorization framework enables a client to obtain
    limited access to a resource with the permission of a resource
    owner.  Authorization information, or references to it, is passed between the nodes
    using access tokens.  These access tokens are issued to clients by an
    authorization server with the approval of the resource owner.  The client
    uses the access token to access the protected resources hosted by the
    resource server.</t>

    <t>A number of OAuth 2.0 terms are used within this specification:

      <list style="hanging">
        <t hangText="The token and introspect Endpoints:"><vspace blankLines="1"/>
          The AS hosts the /token endpoint that allows a client to request access tokens. The client makes a POST request to the /token endpoint on the AS and
          receives the access token in the response (if the request was successful).
          <vspace blankLines="1"/>
          The token introspection endpoint, /introspect, is used by the RS when
          requesting additional information regarding a received access token.
          The RS makes a POST request to /introspect on the AS and receives
          information about the access token contain in the response. (See "Introspection" below.)
          <vspace blankLines="1"/>
        </t>

        <t hangText="Access Tokens:"><vspace blankLines="1"/>
        Access tokens are credentials needed to access protected resources.  An
        access token is a data structure representing authorization permissions
        issued by the AS to the client.  Access tokens are generated by the authorization
        server and consumed by the resource server.  The access token content is opaque
        to the client.
        <vspace blankLines="1"/>
        Access tokens can have different formats, and various methods
        of utilization (e.g., cryptographic properties) based on the security
        requirements of the given deployment.
        <vspace blankLines="1"/>
      </t>


      <t hangText="Proof of Possession Tokens:"><vspace blankLines="1"/>
        An access token may be bound to a
        cryptographic key, which is then used by an RS to authenticate requests
        from a client.  Such tokens are called proof-of-possession tokens (or
        PoP tokens).
        <vspace blankLines="1"/>
        The proof-of-possession (PoP) security concept assumes that the AS acts
        as a trusted third party that binds keys to access tokens.  These so
        called PoP keys are then used by the client to demonstrate the
        possession of the secret to the RS when accessing the resource.  The
        RS, when receiving an access token, needs to verify that the key used
        by the client matches the one bound to the access token.  When this
        specification uses the term "access token" it is assumed to be a PoP token unless
        specifically stated otherwise.

        <vspace blankLines="1"/>
        The key bound to the access token (aka PoP key) may be based on
        symmetric as well as on asymmetric cryptography.  The appropriate
        choice of security depends on the constraints of the IoT devices as
        well as on the security requirements of the use case.

        <list style="hanging">

          <t hangText="Symmetric PoP key:">
              The AS generates a random symmetric PoP key.  The key is either
              stored to be returned on introspection calls or encrypted and
              included in the access token.  The PoP key is also
              encrypted for the client and sent together with the access token
              to the client.<vspace blankLines="0"/>

          </t>
          <t hangText="Asymmetric PoP key:">
              An asymmetric key pair is generated on the client and the public
              key is sent to the AS (if it does not already have knowledge of
              the client's public key).  Information about the public key,
              which is the PoP key in this case, is either
              stored to be returned on introspection calls or included inside the
              access token and sent back to the requesting client.  The RS
	      can identify the client's public key from the information in the
	      token, which allows the client to use the corresponding private
	      key for the proof of possession.
          </t>
        </list>

        <vspace blankLines="1"/> The access token is
        protected against modifications using a MAC or a digital signature,
	which is added by the AS.  The choice of PoP key does not necessarily
	imply a specific credential type for the integrity protection of the
	token.<vspace blankLines="0"/>
      </t>

      <t hangText="Scopes and Permissions:"><vspace blankLines="1"/>
         In OAuth 2.0, the client specifies the type of permissions it is
         seeking to obtain (via the scope parameter) in the access token request.  In
         turn, the AS may use the scope response parameter to inform the
         client of the scope of the access token issued.  As the client could
	 be a constrained device as well, this specification uses CBOR encoded messages
         for CoAP, defined in <xref target="oauthProfile" />, to
         request scopes and to be informed what scopes the access token was
         actually authorized for by the AS.
         <vspace blankLines="1"/>
         The values of the scope parameter are expressed as a list of space-
         delimited, case-sensitive strings, with a semantic that is well-known
	 to the AS and the RS.
         <!-- <vspace blankLines="1"/>
         A common misconception is that the requested scopes must
         also be included in the returned access token, but the requested scopes
         are only metadata about the token.  They could also be packaged in the
         token as a separate attribute, but it's more common to assert the
         requested and authorized access using claims within the access token.
         <vspace blankLines="1"/>-->
         More details about the concept of scopes is found under Section 3.3 in
         <xref target="RFC6749" />.<vspace blankLines="0"/>
      </t>


      <t hangText="Claims:"><vspace blankLines="1"/>

      Information carried in the access token or returned from introspection, called claims, is in the form of
      type-value pairs.  An access token may, for example, include a claim
      identifying the AS that issued the token (via the "iss" claim) and
      what audience the access token is intended for (via the "aud" claim).
	The audience of an access token can be a specific resource or one or
	many resource servers.  The resource owner policies influence what
	claims are put into the access token by the authorization server.
        <vspace blankLines="1"/>
        While the structure and encoding of the access token varies throughout
        deployments, a standardized format has been defined with the JSON Web
        Token (JWT) <xref target="RFC7519"/> where claims are encoded as a
	JSON object.  In <xref target="I-D.ietf-ace-cbor-web-token"/> an
	equivalent format using CBOR encoding (CWT) has been defined.
	<vspace blankLines="0"/>
      </t>

      <t hangText="Introspection:"><vspace blankLines="1"/>
        Introspection is a method for a resource server to query the
        authorization server for the active state and content of a received
        access token.  This is particularly useful in those cases where the
        authorization decisions are very dynamic and/or where the received
        access token itself is a reference rather than a self-contained
        token.   More information about introspection in OAuth 2.0 can be
        found in <xref target="RFC7662"/>.
      </t>
    </list>
  </t>
</section>

<section anchor="coap" title="CoAP">

    <t>
    CoAP is an application layer protocol similar to HTTP, but specifically
    designed for constrained environments.  CoAP typically uses
    datagram-oriented transport, such as UDP, where reordering and loss
    of packets can occur.  A security solution need to take the latter aspects
    into account.</t>

    <t>While HTTP uses headers and query-strings to convey additional
    information about a request, CoAP encodes such information in so-called
    'options'.</t>

    <t>CoAP supports application-layer fragmentation of the CoAP payloads
    through blockwise transfers <xref target="I-D.ietf-core-block"/>.  However,
    block-wise transfer does not increase the size limits of CoAP options,
    therefore data encoded in options has to be kept small.
 </t>

  <t>Transport layer security for CoAP can be provided by DTLS 1.2
    <xref target="RFC6347"/> or TLS 1.2 <xref target="RFC5246"/>.
    CoAP defines a number of proxy operations which requires transport layer
    security to be terminated at the proxy. One approach for protecting CoAP communication
    end-to-end through proxies, and also to support security for CoAP over
    different transport in a uniform way, is to provide security on application
    layer using an object-based security mechanism such as COSE <xref target="I-D.ietf-cose-msg"/>.
  </t>

  <t>
    One application of COSE is OSCOAP
    <xref target="I-D.selander-ace-object-security"/>, which
    provides end-to-end confidentiality, integrity and replay protection, and a
    secure binding between CoAP request and response messages. In OSCOAP, the
    CoAP messages are wrapped in COSE objects and sent using CoAP.
  </t>

</section>
</section>


<!-- ***************************************************** -->
<section anchor="specs" title="Protocol Interactions">

<t>
    The ACE framework is based on the OAuth 2.0 protocol interactions using
    the /token and /introspect endpoints.
    A client obtains an access token from an AS using the /token endpoint and
    subsequently presents the access token
    to a RS to gain access to a protected resource.
    The RS, after receiving an access token, may present it to the AS via the /introspect endpoint to get
    information about the access token. In other deployments
    the RS may process the access token locally without the need to contact an AS.
    These interactions are
    shown in <xref target="fig:protocolFlow"/>.  An overview of various OAuth
    concepts is provided in <xref target="oauth2Overview"/>.
</t>

<t>
    The consent of the resource owner, for giving a client access to a protected
    resource, can be provdied dynamically as in the traditional OAuth flows, or it
    could be pre-configured by the resource owner as authorization policies at
    the AS, which the AS evaluates when a token request arrives.  The resource
    owner and the requesting party (i.e. client owner) are not shown in <xref
    target="fig:protocolFlow"/>.
</t>

<t>
  This framework supports a wide variety of communication security mechanisms
  between the ACE entities, such as client,
  AS, and RS. We assume that the client has been
  registered (also called enrolled or onboarded) to an AS using a mechanism defined outside the scope of this document.
  In practice, various techniques for onboarding have been used, such as factory-based provisioning or the use of
  commissioning tools. Regardless of the onboarding technique, this registration procedure implies that the client and the AS share credentials, and
  configuration parameters.  These credentials are used to mutually authenticate each other and to protect messages exchanged between the client and the AS.</t>

 <t>It is also assumed that the RS has been registered with the AS, potentially in a similar way as the client has been registered with the AS.
 Established keying material between the AS and the RS allows the AS to apply
 cryptographic protection to the access token to ensure that its content cannot
 be modified, and if needed, that the content is confidentiality protected.</t>

<t>The keying material necessary for establishing communication security
  between C and RS is dynamically established as part of the protocol described
  in this document.
</t>

<t>
    At the start of the protocol there is an optional discovery step where the
    client discovers the resource server and the resources this server hosts.
    In this step the client might also determine what permissions are needed to
    access the protected resource.  The detailed procedures for this discovery process
    may be defined in an
    ACE profile and depend on the
    protocols being used and the specific deployment environment.</t>
<t> In Bluetooth
    Low Energy, for example, advertisements are broadcasted by a peripheral,
    including information about the primary services.  In CoAP, as a second
    example, a client can make a request to "/.well-known/core" to obtain
    information about available resources, which are returned in a
    standardized format as described in <xref target="RFC6690"/>.
</t>

<t><figure align="center" anchor="fig:protocolFlow"
           title="Basic Protocol Flow.">
  <artwork align="left"><![CDATA[
+--------+                               +---------------+
|        |---(A)-- Token Request ------->|               |
|        |                               | Authorization |
|        |<--(B)-- Access Token ---------|    Server     |
|        |       + RS Information        |               |
|        |                               +---------------+
|        |                                      ^ |
|        |            Introspection Request  (D)| |
| Client |                                      | |
|        |             Response + Client Token  | |(E)
|        |                                      | v
|        |                               +--------------+
|        |---(C)-- Token + Request ----->|              |
|        |                               |   Resource   |
|        |<--(F)-- Protected Resource ---|    Server    |
|        |                               |              |
+--------+                               +--------------+
  ]]></artwork>
</figure></t>

<t>
  <list style="hanging">
    <t hangText="Requesting an Access Token (A):"><vspace blankLines="1"/>
      The client makes an access token request to the /token endpoint at the AS.
      This framework assumes
      the use of PoP tokens (see <xref target="oauth2Overview"/> for a short
      description) wherein the AS binds a key to an access token.  The client
      may include permissions it seeks to obtain, and information about the
      credentials it wants to use (e.g., symmetric/asymmetric
      cryptography or a reference to a specific credential).<vspace blankLines="0"/>
    </t>

    <t hangText="Access Token Response (B):"><vspace blankLines="1"/>
      If the AS successfully processes the request from the client, it returns
      an access token.  It also returns various parameters, referred as
      "RS Information".  In addition to the response parameters defined by
      OAuth 2.0 and the PoP token extension, further response
      parameters, such as information on
      which profile the client should use with the resource server(s). More
      information about these parameters can be found in in <xref target="tokenParams"/>.
      <vspace blankLines="0"/>
    </t>

    <t hangText="Resource Request (C):"><vspace blankLines="1"/>
      The client interacts with the RS to request access to the protected
      resource and provides the access token.  The protocol to use
      between the client and the RS is not restricted to CoAP. HTTP, HTTP/2,
      QUIC, MQTT, Bluetooth Low Energy, etc., are also viable candidates.
      <vspace blankLines="1"/>
      Depending on the device limitations and the selected protocol this
      exchange may be split up into two parts:

<list style="empty">
<t>(1) the client sends the access token containing, or referencing, the authorization information
      to the RS, that may be used for
      subsequent resource requests by the client, and </t>
<t>(2) the client makes the resource access request, using the communication security protocol and other
    RS Information obtained from the AS.</t>
</list>

      <vspace blankLines="1"/>
      The Client and the RS mutually authenticate using the security protocol
      specified in the profile (see step B) and the keys obtained in the access
      token or the RS Information or the client token.  The RS verifies
      that the token is integrity protected by the AS and compares the claims
      contained in the access token with the resource request. If the RS is
      online, validation can be handed over to the AS using token introspection
      (see messages D and E) over HTTP or CoAP, in  which case the different
      parts of step C may be interleaved with
      introspection.<vspace blankLines="0"/>
    </t>

    <t hangText="Token Introspection Request (D):"><vspace blankLines="1"/>
      A resource server may be configured to introspect the access token by
      including it in a request to the /introspect endpoint at that AS.
      Token introspection over
      CoAP is defined in <xref target="introspectionEndpoint"/> and for HTTP in
      <xref target="RFC7662"/>.
      <vspace blankLines="1"/>
      Note that token introspection is an optional step and can be omitted if
      the token is self-contained and the resource server is prepared to
      perform the token validation on its own.<vspace blankLines="0"/>
    </t>

    <t hangText="Token Introspection Response (E):"><vspace blankLines="1"/>
      The AS validates the token and returns the most recent parameters, such
      as scope, audience, validity etc. associated with it back to the RS.  The
      RS then uses the received parameters to process the request to either
      accept or to deny it. The AS can additionally return information that the
      RS needs to pass on to the client in the form of a client token.  The
      latter is used to establish keys for mutual authentication between
      client and RS, when the client has no direct connectivity to the
      AS.<vspace blankLines="0"/>
    </t>

    <t hangText="Protected Resource (F):"><vspace blankLines="1"/>
      If the request from the client is authorized, the RS fulfills the request
      and returns a response with the appropriate response code.  The RS uses
      the dynamically established keys to protect the response, according to
      used communication security protocol.
    </t>
  </list>
  </t>
</section>



<!-- ***************************************************** -->

<section anchor="oauthProfile" title="Framework">

  <t>The following sections detail the profiling and extensions of OAuth 2.0
  for constrained environments which constitutes the ACE framework.
  </t>

  <t>
    <list style="hanging">
      <t hangText="Credential Provisioning"><vspace blankLines="1"/>
        For IoT we cannot generally assume that the client and RS are part of a
	common key infrastructure, so the AS provisions credentials or
	associated information to allow mutual authentication. These
	credentials need to be provided to the parties before or during the
	authentication protocol is executed, and may be re-used for subsequent
	token requests.
        <vspace blankLines="0"/>
      </t>

      <t hangText="Proof-of-Possession"><vspace blankLines="1"/>
        The ACE framework by default implements proof-of-possession for
	access tokens, i.e. that the token holder can prove being a holder of
	the key bound to the token.  The binding is provided by the "cnf" claim
	indicating what key is used for mutual authentication. If clients need
	to update a token, e.g. to get additional rights, they can request that
	the AS binds the new access token to the same credential as the
	previous token.
        <vspace blankLines="0"/>
      </t>

      <t hangText="ACE Profiles"><vspace blankLines="1"/>
        The client or RS may be limited in the encodings or protocols it
        supports.  To support a variety of different deployment settings,
        specific interactions between client and RS are defined in an ACE
        profile.  In ACE framework the AS is expected to manage the matching
	of compatible profile choices between a client and an RS.  The AS
	informs the client of the selected profile using the "profile"
	parameter in the token request and token response.
        <vspace blankLines="0"/>
      </t>
    </list>
  </t>

  <t>OAuth 2.0 requires the use of TLS both to protect the communication
  between AS and client when requesting an access token; between client and RS
  when accessing a resource and between AS and RS
  for introspection.  In constrained settings TLS is not always feasible,
  or desirable.  Nevertheless it is REQUIRED that the
  data exchanged with the AS is encrypted and integrity protected.  It is
  furthermore REQUIRED that the AS and the endpoint communicating with it
  (client or RS) perform mutual authentication.</t>

  <t>Profiles are expected to specify the details of how this is done,
  depending e.g. on the communication protocol and the credentials used by the
  client or the RS.
  </t>

  <t>In OAuth 2.0 the communication with the Token and the Introspection
  endpoints at the AS is assumed to be via HTTP and may use Uri-query
  parameters.  This framework RECOMMENDS to use CoAP instead and RECOMMENDS the
  use of the following alternative instead of Uri-query parameters: The sender
  (client or RS) encodes the parameters of its request as a CBOR map and
  submits that map as the payload  of the POST request.  The Content-format
  depends on the security applied to the content and must be specified by the
  corresponding profile.
  </t>

  <t>The OAuth 2.0 AS uses a JSON structure in the payload of its responses
  both to client and RS.  This framework RECOMMENDS the use of CBOR
  <xref target="RFC7049"/> instead.  The requesting device can explicitly
  request this encoding by setting the CoAP Accept option in the request to
  "application/cbor".  Depending on the profile, the content may arrive in a
  different format wrapping a CBOR payload.</t>

</section> <!--Framework-->

<section anchor="tokenEndpoint" title="The 'Token' Endpoint">

  <t>In plain OAuth 2.0 the AS provides the /token endpoint for submitting
  access token requests.  This framework extends the functionality of the
  /token endpoint, giving the AS the possibility to help client and RS to
  establish shared keys or to exchange their public keys.  Furthermore
  this framework defines encodings using CoAP and CBOR, instead of
  HTTP and JSON.</t>

  <t>Communication between the client and the /token endpoint at the
    AS MUST be integrity protected and encrypted.  Furthermore AS and client
    MUST perform mutual authentication.  Profiles of this framework are
    expected to specify how authentication and communication security is
    implemented.
  </t>

  <t>The figures of this section uses CBOR diagnostic
  notation without the integer abbreviations for the parameters or their
  values for better readability.
  </t>

  <section anchor="tokenRequest" title="Client-to-AS Request">
    <t>The client sends a CoAP POST request to the token endpoint
    at the AS, the profile is expected to specify the Content-Type
    and wrapping of the payload.  The content of the request consists of the
    parameters specified in section 4 of the OAuth 2.0 specification <xref
    target="RFC6749"/> encoded as a CBOR map.</t>

    <t>In addition to these parameters, this framework defines the following
    parameters for requesting an access token from a /token endpoint:

      <list style="hanging">
	<t hangText="aud"><vspace blankLines="0"/>
	OPTIONAL.  Specifies the audience for which the client is
	requesting an access token.  If this parameter is missing it is
	assumed that the client and the AS have a pre-established understanding
	of the audience that an access token should address.  If a client
	submits a request for an access token without specifying an "aud"
	parameter, and the AS does not have a default "aud" value for 
	this client, then the AS MUST respond with an error message 
	with the CoAP response code 4.00 (Bad Request).
	<vspace blankLines="1"/></t>

	<t hangText="cnf"><vspace blankLines="0"/>
	OPTIONAL.  This field contains information about the key the
	client would like to bind to the access token for proof-of-possession.
	It is NOT RECOMMENDED that a client submits a symmetric key value to
	the AS using this parameter.  See <xref target="paramCnf"/> for more
	details on the formatting of the 'cnf' parameter.</t>  	
      </list>
    </t>

    <t>The following examples illustrate different types of requests
    for proof-of-possession tokens. </t>

    <t><xref target="fig:symmATreq"/> shows a request for a token
    with a symmetric proof-of-possession key.  Note that in this example
    we assume a DTLS-based communication security profile, therefore
    the Content-Type is "application/cbor".

    <figure align="center" anchor="fig:symmATreq"
            title="Example request for an access token bound to a
		   symmetric key.">
        <artwork align="left"><![CDATA[
Header: POST (Code=0.02)
Uri-Host: "server.example.com"
Uri-Path: "token"
Content-Type: "application/cbor"
Payload:
{
  "grant_type" : "client_credentials",
  "aud" : "tempSensor4711",
 }
        ]]></artwork>
    </figure></t>

    <t><xref target="fig:asymmATreq"/> shows a request for a token with an
    asymmetric proof-of-possession key.  Note that in this example we assume
    an object security-based profile, therefore the Content-Type is
    "application/cose+cbor".

    <figure align="center" anchor="fig:asymmATreq"
            title="Example request for an access token bound to an
		   asymmetric key.">
        <artwork align="left"><![CDATA[
Header: POST (Code=0.02)
Uri-Host: "server.example.com"
Uri-Path: "token"
Content-Type: "application/cose+cbor"
Payload:
{
  "grant_type" : "client_credentials",
  "cnf" : {
    "COSE_Key" : {
      "kty" : "EC",
      "kid" : h'11',
      "crv" : "P-256",
      "x" : b64'usWxHK2PmfnHKwXPS54m0kTcGJ90UiglWiGahtagnv8',
      "y" : b64'IBOL+C3BttVivg+lSreASjpkttcsz+1rb7btKLv8EX4'
    }
  }
}
        ]]></artwork>
    </figure></t>

    <t><xref target="fig:kidATreq"/> shows a request for a token
    where a previously communicated proof-of-possession key is only
    referenced.  Note that we assume a DTLS-based communication security
    profile for this example, therefore the Content-Type is
    "application/cbor".  Also note that the client performs a password
    based authentication in this example by submitting its client_secret.

    <figure align="center" anchor="fig:kidATreq"
            title="Example request for an access token bound to a
		   key reference.">
        <artwork align="left"><![CDATA[
Header: POST (Code=0.02)
Uri-Host: "server.example.com"
Uri-Path: "token"
Content-Type: "application/cbor"
Payload:
{
  "grant_type" : "client_credentials",
  "client_id" : "myclient",
  "client_secret" : "mysecret234",
  "aud" : "valve424",
  "scope" : "read",
  "cnf" : {
    "kid" : b64'6kg0dXJM13U'
  }
}
       ]]></artwork>
    </figure></t>

  </section>

  <section anchor="tokenResponse" title="AS-to-Client Response">
    <t>If the access token request has been successfully verified by the
    AS and the client is authorized to obtain an access token corresponding
    to its access token request, the AS sends a response with the CoAP response
    code 2.01 (Created).  If client request was invalid, or not authorized, the
    AS returns an error response as described in <xref
    target="errorsToken"/>.</t> 

    <t>Note that the AS decides which token type and profile to use when
    issuing a successful response.  It is assumed that the AS has prior
   knowledge of the capabilities of the client, and the RS.  This prior
   knowledge may, for example, be set by the use of a dynamic client
   registration protocol exchange <xref target="RFC7591"/>.</t>

    <t>The content of the successful reply MUST be encoded as CBOR
    map, containing paramters as speficied in section 5.1 of <xref
    target="RFC6749"/>.  In addition to these parameters, the following
    parameters are also part of a successful response: 

    <list style="hanging">
	<t hangText="profile"><vspace blankLines="0"/>
	REQUIRED.  This indicates the profile that the client MUST use
	towards the RS. See <xref target="paramProfile"/> for the formatting of
	this parameter.<vspace blankLines="1"/></t>

	<t hangText="cnf"><vspace blankLines="0"/>
	REQUIRED if the token type is 'pop'. OPTIONAL otherwise.  If a
	symmetric proof-of-possession algorithms was selected, this field
	contains the proof-of-possession key.  If an asymmetric algorithm was
	selected, this field contains information about the public key used by
	the RS to authenticate.  See <xref target="paramCnf"/> for the
	formatting of this parameter.</t> 

	<t hangText="token_type"><vspace blankLines="0"/>
	OPTIONAL.  By default implementations of this framework SHOULD assume
	that the token_type is 'pop'.  If a specific use case requires another
	token_type (e.g. 'Bearer') to be used then this parameter is REQUIRED.
	</t>
      </list>
    </t>

    <t>Note that if CBOR Web Tokens <xref
    target="I-D.ietf-ace-cbor-web-token"/> are used, the access token can also
    contain a 'cnf' claim.  This claim is however consumed by a different
    party.  The access token is created by the AS and processed by the RS (and
    opaque to the client) whereas the RS Information is created by the AS and
    processed by the client; it is never forwarded to the resource server.</t> 

    <t>The following examples illustrate different types of responses
    for proof-of-possession tokens.
    </t>

    <t><xref target="fig:symmATres"/> shows a response containing a token
    and a 'cnf' parameter with a symmetric proof-of-possession key.  Note that
    we assume a DTLS-based communication security profile for this example,
    therefore the Content-Type is "application/cbor".

    <figure align="center" anchor="fig:symmATres"
            title="Example AS response with an access token bound to a
		   symmetric key.">
      <artwork align="left"><![CDATA[
Header: Created (Code=2.01)
Content-Type: "application/cbor"
Payload:
{
  "access_token" : b64'SlAV32hkKG ...
   (remainder of CWT omitted for brevity;
   CWT contains COSE_Key in the 'cnf' claim)',
  "expires_in" : "3600",
  "cnf" : {
    "COSE_Key" : {
      "kty" : "Symmetric",
      "kid" : b64'39Gqlw',
      "k" : b64'hJtXhkV8FJG+Onbc6mxCcQh'
    }
  }
}
      ]]></artwork>
    </figure></t>
  </section>

  <section anchor="errorsToken" title="Error Response">
    <t>The error responses for CoAP-based interactions with the AS
    are equivalent to the ones for HTTP-based interactions as defined in
    section  5.2 of <xref target="RFC6749"/>, with the following differences:
    The Content-Type is specified by the communication security profile used
    between client and AS.  The raw payload before being processed by the
    communication security protocol MUST be encoded as a CBOR map and the CoAP
    response code 4.00 (Bad Request) MUST be used unless specified otherwise.
    </t>
  </section>

  <section anchor="tokenParams"
	   title="New Request and Response Parameters">
    <t>This section provides more detail about the new parameters that can be
    used in access token requests and responses, as well as abbreviations for
    more compact encoding of existing parameters and common parameter
    values.</t> 

    <section anchor="paramAud" title="Audience">
      <t>This parameter specifies for which audience the client is requesting
      a token.  It should be encoded as CBOR text string (major type 3).  The
      formatting and semantics of these strings are application specific.</t>
    </section>

    <section anchor="paramGrantType" title="Grant Type">
      <t>The abbreviations in <xref target="fig:grant_types"/> MAY be
      used in CBOR encodings instead of the string values defined
      in <xref target="RFC6749"/>.

       <figure align="center" anchor="fig:grant_types"
	       title="CBOR abbreviations for common grant types ">
	 <artwork align="left"><![CDATA[
          /--------------------+----------+--------------\
          | grant_type         | CBOR Key | Major Type   |
          |--------------------+----------+--------------|
          | password           |    0     |     0 (uint) |
          | authorization_code |    1     |     0        |
          | client_credentials |    2     |     0        |
          | refresh_token      |    3     |     0        |
          \--------------------+----------+--------------/
        ]]></artwork>
      </figure></t>
    </section>

    <section anchor="paramTokenType" title="Token Type">
      <t>The 'token_type' parameter allows the AS to indicate to the
      client which type of access token it is receiving (e.g. a bearer token).
      The 'pop' token type MUST be assumed by default if the AS does not
      provide a different value.</t> 
 
      <t>This document registers the new value "pop" for the OAuth Access
        Token Types registry,  specifying a Proof-of-Possession token.  How the
      proof-of-possession is performed is specified by the profiles.</t>

      <t>The values in the 'token_type' parameter are CBOR text strings
      (major type 3).</t>
      
    </section>

    <section anchor="paramProfile" title="Profile">

      <t>Profiles of this framework are expected to define the communication
      protocol and the communication security protocol between the client
      and the RS.  Furthermore profiles are expected to define
      proof-of-possession methods, if they support proof-of-possession
      tokens.</t> 

      <t>A profile should specify an identifier that is used to uniquely
      identify itself in the 'profile' parameter.</t>

      <t>Profiles MAY define additional parameters for both the token request
      and the RS Information in the access token response in order to
      support negotioation or signalling of profile specific parameters.
      </t>
    </section>

    <section anchor="paramCnf" title="Confirmation">
      <t>The "cnf" parameter identifies or provides the key used for
      proof-of-possession or for authenticating the RS depending on the
      proof-of-possession algorithm and the context cnf is used in.  This
      framework extends  the definition of 'cnf' from <xref target="RFC7800"/>
      by adding CBOR/COSE encodings and the use of 'cnf' for transporting keys
      in the RS Information.</t>

      <t>A CBOR encoded payload MAY contain the 'cnf' parameter with the
      following contents:

      <list style="hanging">
	<t hangText="COSE_Key">In this case the 'cnf' parameter contains
	 the proof-of-possession key to be used by the client.  An example
	 is shown in <xref target="fig:cnfKey"/>. 

	 <figure align="center" anchor="fig:cnfKey"
	       title="Confirmation parameter containing a public key">
	 <artwork align="left"><![CDATA[
"cnf" : {
  "COSE_Key" : {
    "kty" : "EC",
    "kid" : h'11',
    "crv" : "P-256",
    "x" : b64'usWxHK2PmfnHKwXPS54m0kTcGJ90UiglWiGahtagnv8',
    "y" : b64'IBOL+C3BttVivg+lSreASjpkttcsz+1rb7btKLv8EX4'
  }
}
        ]]></artwork>
      </figure> <vspace blankLines="1"/>

      Note that the COSE_Key structure may contain an "alg" or "key_ops"
      parameter.  If such parameters are present, a client MUST NOT use a key
      that is not compatible with the profile or proof-of-possession algorithm
      according to those parameters.
    </t>

	<t hangText="COSE_Encrypted">In this case the 'cnf' parameter
	contains an encrypted symmetric key destined for the client.  The
	client is assumed to be able to decrypt the cihpertext of this
	parameter.  The parameter is encoded as COSE_Encrypted object wrapping
	a COSE_Key object.  <xref target="fig:cnfEnc"/> shows an example of
	this type of encoding.

	 <figure align="center" anchor="fig:cnfEnc"
	       title="Confirmation paramter containing an encrypted
		      symmetric key">
	 <artwork align="left"><![CDATA[
"cnf" : {
  "COSE_Encrypted" : {
    993(
      [ h'a1010a' # protected header : {"alg" : "AES-CCM-16-64-128"}
        "iv" : b64'ifUvZaHFgJM7UmGnjA',  # unprotected header
       b64'WXThuZo6TMCaZZqi6ef/8WHTjOdGk8kNzaIhIQ' # ciphertext
      ]
    )
  }
}
        ]]></artwork>
      </figure>

      The ciphertext here could e.g. contain a symmetric key as in
      <xref target="fig:cnfEKey"/>.

      <figure align="center" anchor="fig:cnfEKey"
	       title="Example plaintext of an encrypted cnf parameter">
	 <artwork align="left"><![CDATA[
{
  "kty" : "Symmetric",
  "kid" : b64'39Gqlw',
  "k" : b64'hJtXhkV8FJG+Onbc6mxCcQh'
}
        ]]></artwork>
      </figure>
      <vspace blankLines="1"/>
      </t>

      <t hangText="Key Identifier">In this case the 'cnf' parameter
      references a key that is assumed to be previously known by the
      recipient.  This allows clients that perform repeated requests for an
      access token for the same audience but e.g. with different scopes to
      omit key transport in the access token, token request and token
      response. <xref target="fig:cnfKid"/> shows such an example.

	<figure align="center" anchor="fig:cnfKid"
	       title="A Confirmation parameter with just a key identifier">
	 <artwork align="left"><![CDATA[
"cnf" : {
  "kid" : b64'39Gqlw'
}
        ]]></artwork>
      </figure>
      </t>
      </list></t>
    </section>
  </section> <!--Parameters -->

  <section anchor="tokenCborParams" title="Mapping parameters to CBOR">
    <t>All OAuth parameters in access token requests and responses are mapped
    to CBOR types as follows and are given an integer key value to save
    space.</t>

    <t>
      <figure align="center" anchor="fig:cborTokenParameters"
	      title="CBOR mappings used in token requests">
      <artwork align="left"><![CDATA[
        /-------------------+----------+-----------------\
        | Parameter name    | CBOR Key | Major Type      |
        |-------------------+----------+-----------------|
        | aud               | 3        | 3               |
        | client_id         | 8        | 3 (text string) |
        | client_secret     | 9        | 2 (byte string) |
        | response_type     | 10       | 3               |
        | redirect_uri      | 11       | 3               |
        | scope             | 12       | 3               |
        | state             | 13       | 3               |
        | code              | 14       | 2               |
        | error_description | 15       | 3               |
        | error_uri         | 16       | 3               |
        | grant_type        | 17       | 0 (unit)        |
        | access_token      | 18       | 3               |
        | token_type        | 19       | 0               |
        | expires_in        | 20       | 0               |
        | username          | 21       | 3               |
        | password          | 22       | 3               |
        | refresh_token     | 23       | 3               |
        | cnf               | 24       | 5 (map)         |
        | profile           | 25       | 3               |
        \-------------------+----------+-----------------/
      ]]></artwork>
    </figure>
  </t>
  </section>
</section><!-- Token endpoint -->

<section anchor="introspectionEndpoint" title="The 'Introspect' Endpoint">
  <t>Token introspection <xref target="RFC7662"/> is used by the RS and
  potentially the client to query the AS for metadata about a given token
  e.g. validity or scope. Analogous to the protocol defined in
  RFC 7662 <xref target="RFC7662"/> for HTTP and JSON, this section defines
  adaptations to more constrained  environments using CoAP and CBOR.</t>

  <t>Communication between the RS and the introspection endpoint at the
  AS MUST be integrity protected and encrypted.  Furthermore AS and RS
  MUST perform mutual authentication.  Finally the AS SHOULD verify that the
  RS has the right to access introspection information about the provided
  token.  Profiles of this framework are expected to specify how
  authentication and communication security is implemented.</t>

  <t>The figures of this section uses CBOR diagnostic
  notation without the integer abbreviations for the parameters or their
  values for better readability.
  </t>

  <section anchor="introRS2AS" title="RS-to-AS Request">
    <t>The RS sends a CoAP POST request to the introspection endpoint
    at the AS, the profile is expected to specify the Content-Type and
    wrapping of the payload.  The payload MUST be encoded as a CBOR map with a
    'token' parameter containing the access token along with optional
    parameters representing additional context that is known by 
    the RS to aid the AS in its response.</t>

    <t>The same parameters are required and optional as in section 2.1
    of RFC 7662 <xref target="RFC7662"/>.</t>

    <t>For example, <xref target="fig:introReq"/> shows a RS calling the token
    introspection endpoint at the AS to query about an OAuth 2.0
    proof-of-possession token.  Note that we assume a object security-based
    communication security profile for this example, therefore the Content-Type
    is "application/cose+cbor".

    <figure align="center" anchor="fig:introReq"
            title="Example introspection request.">
        <artwork align="left"><![CDATA[
Header: POST (Code=0.02)
Uri-Host: "server.example.com"
Uri-Path: "introspect"
Content-Type: "application/cose+cbor"
Payload:
{
  "token" : b64'7gj0dXJQ43U',
  "token_type_hint" : "pop"
}
       ]]></artwork>
    </figure></t>
  </section>

  <section anchor="introAS2RS" title="AS-to-RS Response">
    <t>If the introspection request is authorized and successfully processed,
    the AS sends a response with the CoAP response code 2.01 (Created).  If the
    introspection request was invalid, not authorized or couldn't be processed
    the AS returns an error response as described in <xref
    target="errorsIntro"/>.</t>
    
    <t>In a successful response, the AS encodes the response parameters in
    a CBOR map including with the same required and optional parameters as in
    section 2.2. of RFC 7662 <xref target="RFC7662"/> with the following
    additions: 

    <list style="hanging">

      <t hangText="cnf"><vspace blankLines="0"/>
      OPTIONAL.   This field contains information about the proof-of-possession
      key that binds the client to the access token.  See <xref
      target="paramCnf"/> for more details on the formatting of the 'cnf'
      parameter.<vspace blankLines="1"/></t>

      <t hangText="profile"><vspace blankLines="0"/>
      OPTIONAL.  This indicates the profile that the RS MUST use with the
      client.  See <xref target="paramProfile"/> for more details on the
      formatting of this parameter.
      <vspace blankLines="1"/></t>

      <t hangText="client_token"><vspace blankLines="0"/>
      OPTIONAL.  This parameter contains information that the RS
      MUST pass on to the client.  See <xref target="clientToken"/>
      for more details.</t>
    </list>
    </t>

    <t>For example, <xref target="fig:introRes"/> shows an AS
    response to the introspection request in <xref target="fig:introReq"/>.
    Note that we assume a DTLS-based communication security profile for this
    example, therefore the Content-Type is "application/cbor".


    <figure align="center" anchor="fig:introRes"
            title="Example introspection response.">
      <artwork align="left"><![CDATA[
Header: Created Code=2.01)
Content-Type: "application/cbor"
Payload:
{
  "active" : true,
  "scope" : "read",
  "profile" : "coap_dtls",
  "client_token" : b64'2QPhg0OhAQo ...
  (remainder of client token omitted for brevity)',
  "cnf" : {
    "COSE_Key" : {
      "kty" : "Symmetric",
      "kid" : b64'39Gqlw',
      "k" : b64'hJtXhkV8FJG+Onbc6mxCcQh'
    }
  }
}
      ]]></artwork>
    </figure></t>
  </section>

  <section anchor="errorsIntro" title="Error Response">
    <t>The error responses for CoAP-based interactions with the AS
    are equivalent to the ones for HTTP-based interactions as defined in
    section 2.3 of <xref target="RFC7662"/>, with the following differences:

    <list style="symbols">

      <t>If content is sent, the Content-Type MUST be set according to the
      specification of the communication security profile, and the content
      payload MUST be encoded as a CBOR map.</t>

      <t>If the credentials used by the RS are invalid the AS MUST respond
      with the CoAP response code 4.01 (Unauthorized) and use
      the required and optional parameters from section 5.2 in RFC 6749
      <xref target="RFC6749"/>.</t>

      <t>If the RS does not have the right to perform this introspection
      request, the AS MUST respond with the CoAP response code 4.03
      (Forbidden).  In this case no payload is returned.</t>
    </list>
    </t>

    <t>Note that a properly formed and authorized query for an inactive or
    otherwise invalid token does not warrant an error response by this
    specification.  In these cases, the authorization server MUST instead
    respond with an introspection response with the "active" field set to
    "false".</t>
  </section>

  <section anchor="clientToken" title="Client Token">
    <t>EDITORIAL NOTE: We have tentatively introduced this concept and
    would specifically like feedback if this is viewed as a useful addition
    to the framework.</t>
    <t>In cases where the client has limited connectivity and
    is requesting access to a previously unknown resource servers, using
    a long term token, there are situations where it would be beneficial to
    relay the proof-of-possession key and other relevant information from
    the AS to the client through the RS.  The client_token parameter
    is designed to carry such information, and is intended to be used as
    described in <xref target="fig:client_token"/>.

    <figure align="center" anchor="fig:client_token"
               title="Use of the client_token parameter.">
      <artwork align="left"><![CDATA[
                  Resource       Authorization
 Client            Server           Server
    |                |                |
    |                |                |
C:  +--------------->|                |
    |  POST          |                |
    |  Access Token  |                |
    |            D:  +--------------->|
    |                | Introspection  |
    |                |    Request     |
    |                |                |
    |            E:  +<---------------+
    |                | Introspection  |
    |                |   Response     |
    |                | + Client Token |
    |<---------------+                |
    |  2.01 Created  |                |
    | + Client Token |
    ]]></artwork>
    </figure>
    </t>

    <t>The client token is a COSE_Encrytped object, containing as payload
    a CBOR map with the following claims:

    <list style="hanging">
      <t hangText="cnf"><vspace blankLines="0"/>
      REQUIRED if the token type is 'pop', OPTIONAL otherwise.  Contains
      information about the proof-of-possession key the client is to use with
      its access token.  See <xref target="paramCnf"/>.<vspace
      blankLines="1"/></t> 

      <t hangText="token_type"><vspace blankLines="0"/>
      OPTIONAL. See <xref target="paramTokenType"/>.<vspace
      blankLines="1"/></t>

      <t hangText="profile"><vspace blankLines="0"/>
      REQUIRED. See <xref target="paramProfile"/>.<vspace
      blankLines="1"/></t>

      <t hangText="rs_cnf"><vspace blankLines="0"/>
      OPTIONAL. Contains information about the key that the RS uses
      to authenticate towards the client.  If the key is symmetric then
      this claim MUST NOT be part of the Client Token, since this is the
      same key as the one specified through the 'cnf' claim.  This claim uses
      the same encoding as the 'cnf' parameter.  See <xref
      target="paramProfile"/>.</t>
    </list>
    </t>

    <t>The AS encrypts this token using a key shared between the AS and the
    client, so that only the client can decrypt it and access its payload.
    How this key is established is out of scope of this framework.</t>
  </section>

  <section anchor="introParamsCbor"
	   title="Mapping Introspection parameters to CBOR">
    <t>The introspection request and response parameters are mapped to CBOR
    types as follows and are given an integer key value to save space.

    <figure align="center" anchor="fig:cborIntrospectionParameters"
            title="CBOR Mappings to Token Introspection Parameters.">
      <artwork align="left"><![CDATA[
          /-----------------+----------+-----------------\
          | Parameter name  | CBOR Key | Major Type      |
          |-----------------+----------+-----------------|
          | iss             | 1        | 3 (text string) |
          | sub             | 2        | 3               |
          | aud             | 3        | 3               |
          | exp             | 4        | 6 tag value 1   |
          | nbf             | 5        | 6 tag value 1   |
          | iat             | 6        | 6 tag value 1   |
          | cti             | 7        | 2 (byte string) |
          | client_id       | 8        | 3               |
          | scope           | 12       | 3               |
          | token_type      | 19       | 3               |
          | username        | 21       | 3               |
          | cnf             | 24       | 5 (map)         |
          | profile         | 25       | 0 (uint)        |
          | token           | 26       | 3               |
          | token_type_hint | 27       | 3               |
          | active          | 28       | 0               |
          | client_token    | 29       | 3               |
          | rs_cnf          | 30       | 5               |
          \-----------------+----------+-----------------/
        ]]></artwork>
      </figure>
    </t>
  </section>

</section><!-- introspect endpoint -->

<section title="The Access Token">
  <t>This framework RECOMMENDS the use of CBOR web token (CWT) as
    specified in <xref target="I-D.ietf-ace-cbor-web-token"/>.
  </t>

  <t>In order to facilitate offline processing of access tokens,
  this draft specifies the "cnf" and "scope" claims for CBOR web tokens.</t>

  <t>The "scope" claim explicitly encodes the scope of a given access token.
  This claim follows the same encoding rules as defined in section 3.3 of <xref
  target="RFC6749"/>.  The meaning of a specific scope value is application
  specific and expected to be known to the RS running that application.</t>

 <t>The "cnf" claim follows the same rules as specified for JSON web token
 in RFC7800 <xref target="RFC7800"/>, except that it is encoded in CBOR
 in the same way as specified for the "cnf" parameter in section <xref
 target="paramCnf"/>.</t> 

<section title="The 'Authorization Information' Endpoint">
  <t>The access token, containing authorization information and information of
  the key used by the client, needs to be transported to the RS so that the RS
  can authenticate and authorize the client request.</t>
  
  <t>This section defines a method for transporting the access token to the RS
  using CoAP. Profiles of this framework MAY define other methods for token
  transport.  Implementations conforming to this framework MUST implement 
  this method of token transportation.
  </t>

  <t>The method consists of a /authz-info endpoint, implemented by the 
  RS.  A client using this method MUST make a POST request to /authz-info at
  the RS with the access token in the payload. The RS receiving the token MUST
  verify the validity of the token.  If the token is valid, the RS MUST respond
  to the POST request with 2.04 (Changed).</t>

  <t>If the token is not valid, the RS MUST respond with the CoAP response code
  4.01 (Unauthorized).  If the token is valid but the audience of the
  token does not match the RS, the RS MUST respond with the CoAP response code
  4.03 (Forbidden).
  </t>

  <t>The RS MAY make an introspection request to validate the token before
  responding to the POST /authz-info request. If the introspection response
  contains a client token (<xref target="clientToken"/>) then this token
  SHALL be included in the payload of the 2.04 (Changed) response.
  </t>

  <t>Profiles are expected to specify how the /authz-info endpoint is
  protected.  Note that since the token contains information that allow the
  client and the RS to establish a security context in the first place, mutual
  authentication may not be possible at this point.</t> 
</section>

<section anchor="tokenValidity" title="Token Expiration">
  <t>Depending on the capabilities of the RS, there are various ways in
    which it can verify the validity of a received access token.  We list the
    possibilities here including what functionality they require of the
    RS.</t>

  <t><list style="symbols">
    <t>The token is a CWT/JWT and includes a 'exp' claim and possibly the
    'nbf' claim.  The RS verifies these by comparing them to values from
    its internal clock as defined in <xref target="RFC7519"/>.  In this
    case the RS's internal clock must reflect the current date and time, or
    at least be synchronized with the AS's clock.  How this clock
    synchronization would be performed is out of scope for this memo.</t>

    <t>The RS verifies the validity of the token by performing an
    introspection request as specified in <xref
    target="introspectionEndpoint"/>.  This requires the RS to have a
    reliable network connection to the AS and to be able to handle two
    secure sessions in parallel (C to RS and AS to RS).</t>

    <t>The RS and the AS both store a sequence number linked to their common
    security association.  The AS increments this number for each access
    token it issues and includes it in the access token, which is a
    CWT/JWT.  The RS keeps track of the most recently received sequence
    number, and only accepts tokens as valid, that are in a certain range
    around this number.  This method does only require the RS to keep track
    of the sequence number.  The method does not provide timely expiration,
    but it makes sure that older tokens cease to be valid after a certain
    number of newer ones got issued.  For a constrained RS with no network
    connectivity and no means of reliably measuring time, this is the best
    that can be achieved.</t>

  </list></t>
</section>
</section><!-- access token -->


<section anchor="security" title="Security Considerations">
      <t>The entire document is about security.  Security considerations
      applicable to authentication and authorization in RESTful
      environments provided in OAuth 2.0 <xref target="RFC6749"/> apply to this
      work, as well as the security considerations from
      <xref target="I-D.ietf-ace-actors"/>.  Furthermore
      <xref target="RFC6819"/> provides additional security considerations for
      OAuth which apply to IoT deployments as well.</t>

      <t>A large range of threats can be mitigated by protecting the contents
      of the access token by using a digital signature or a keyed message
      digest.  Consequently, the token integrity protection MUST be applied to
      prevent the token from being modified, particularly since it contains  
      a reference to the symmetric key or the asymmetric key.  If the
      access token contains the symmetric key, this symmetric key MUST be
      encrypted by the authorization server with a long-term key shared with
      the resource server.</t>

      <t>It is important for the authorization server to include the identity
      of the intended recipient (the audience), typically a single resource
      server (or a list of resource servers), in the token.  Using a single
      shared secret with multiple authorization server to simplify key
      management is NOT RECOMMENDED since the benefit from using the
      proof-of-possession concept is significantly reduced.</t>

      <t>Token replay is also not possible since an eavesdropper will also
      have to obtain the corresponding private key or shared secret that is 
      bound to the access token.  Nevertheless, it is good practice to limit
      the lifetime of the access token and therefore the lifetime of 
      associated key.</t>

      <t>The authorization server MUST offer confidentiality protection for
      any interactions with the client.  This step is extremely important
      since the client will obtain the session key from the authorization
      server for use with a specific access token.  Not using confidentiality
      protection exposes this secret (and the access token) to an eavesdropper
      thereby making the proof-of-possession security model completely
      insecure.  This framework relies on profiles to define how 
      confidentiality protection is provided, and additional protection can be
      applied by encrypting the CWT as specified in section 5.1 of
      <xref target="I-D.ietf-ace-cbor-web-token"/> to provide an additional
      layer of protection for cases where keying material is conveyed, for
      example, to a hardware security module.</t>
      
      <t>Developers MUST ensure that the ephemeral credentials (i.e., the
      private key or the session key) is not leaked to third parties.  An
      adversary in possession of the ephemeral credentials bound to the access
      token will be able to impersonate the client.  Be aware that this is a
      real risk with many constrained environments, since adversaries can
      often easily get physical access to the devices.</t>

      <t>Clients can at any time request a new proof-of-possession capable
      access token.  Using a refresh token to regularly request new access
      tokens that are bound to fresh and unique keys is important if the
      client has this capability.  Keeping the lifetime of the access token
      short allows the authorization server to use shorter key sizes, which
      translate to a performance benefit for the client and for the resource
      server.  Shorter keys also lead to shorter messages (particularly with
      asymmetric keying material).</t>

      <t>When authorization servers bind symmetric keys to access tokens then 
      they SHOULD scope these access tokens to a specific permissions.</t>

</section>

<section anchor="iana" title="IANA Considerations">
      <t>This specification registers new parameters for OAuth and establishes registries for mappings to CBOR.</t>

      <section anchor="IANAOAuthIntrospectionResponseParameterRegistrationn" title="OAuth Introspection Response Parameter Registration">
      <t>This specification registers the following parameters in the OAuth introspection response parameters</t>
      <t>
        <?rfc subcompact="yes"?>
        <list style='symbols'>
          <t>Name: <spanx style="verb">cnf</spanx></t>
          <t>Description: Key to use to prove the right to use an access token,
   as defined in <xref target="RFC7800"/>. </t>
          <t>Change Controller: IESG</t>
          <t>Specification Document(s): this document</t>
        </list>
      </t>
      <t>
        <?rfc subcompact="yes"?>
        <list style='symbols'>
          <t>Name: <spanx style="verb">aud</spanx></t>
          <t>Description: reference to intended receiving RS, as defined in PoP token specification.</t>
          <t>Change Controller: IESG</t>
          <t>Specification Document(s): this document</t>
        </list>
      </t>
      <t>
        <?rfc subcompact="yes"?>
        <list style='symbols'>
          <t>Name: <spanx style="verb">profile</spanx></t>
          <t>Description: The communication and communication security
   profile used between client and RS, as defined in ACE profiles.</t>
          <t>Change Controller: IESG</t>
          <t>Specification Document(s): this document</t>
        </list>
      </t>
      <t>
	<?rfc subcompact="yes"?>
        <list style='symbols'>
          <t>Name: <spanx style="verb">client_token</spanx></t>
          <t>Description: Information that the RS MUST pass to the client
	  e.g. about the proof-of-possession keys.</t>
          <t>Change Controller: IESG</t>
          <t>Specification Document(s): this document</t>
	</list>
      </t>
     <t>
	<?rfc subcompact="yes"?>
        <list style='symbols'>
          <t>Name: <spanx style="verb">rs_cnf</spanx></t>
          <t>Description: Describes the public key the RS uses to
	  authenticate.</t>
          <t>Change Controller: IESG</t>
          <t>Specification Document(s): this document</t>
	</list>
      </t>
      </section>

      <section anchor="IANAOAuthParameterRegistration" title="OAuth Parameter Registration">
      <t>This specification registers the following parameters in the OAuth
      Parameters Registry</t>
      <t>
        <?rfc subcompact="yes"?>
        <list style='symbols'>
          <t>Parameter name: <spanx style="verb">profile</spanx></t>
          <t>Parameter usage location: token request, and token response</t>
          <t>Change Controller: IESG</t>
          <t>Specification Document(s): this document</t>
        </list>
      </t>
      <t>
        <?rfc subcompact="yes"?>
        <list style='symbols'>
          <t>Name: <spanx style="verb">cnf</spanx></t>
          <t>Description: Key to use to prove the right to use an access token,
	  as defined in <xref target="RFC7800"/>. </t>
          <t>Change Controller: IESG</t>
          <t>Specification Document(s): this document</t>
        </list>
      </t>
      </section>

      <section anchor="IANAOAuthTokenType" title="OAuth Access Token Types">
	<t>This specification registers the following new token type in the
	OAuth Access Token Types Registry</t>
	<t>
          <?rfc subcompact="yes"?>
          <list style='symbols'>
            <t>Name: <spanx style="verb">PoP</spanx></t>
            <t>Description: A proof-of-possession token.</t>
	    <t>Change Controller: IESG</t>
            <t>Specification Document(s): this document</t>
          </list>
	</t>
      </section>

      <section anchor="IANATokenTypeMappings" title="Token Type Mappings">
        <t>A new registry will be requested from IANA, entitled "Token Type Mappings".  The registry is to be created as Expert Review Required.</t>

        <section anchor="IANATokenTypeMappingsTemplate" title="Registration Template">
          <t>
            <list style='hanging'>
              <t hangText='Token Type:'>
                <vspace/>
                Name of token type as registered in the OAuth token type registry e.g. "Bearer".
              </t>
              <t hangText='Mapped value:'>
                <vspace/>
                Integer representation for the token type value.  The key value MUST be an integer in the range of 1 to 65536.
              </t>
              <t hangText='Change Controller:'>
                <vspace/>
                For Standards Track RFCs, list the "IESG". For others, give the name of the responsible party. Other details (e.g., postal address, email address, home page URI) may also be included.
              </t>
              <t hangText='Specification Document(s):'>
                <vspace/>
                Reference to the document or documents that specify the parameter,preferably including URIs that can be used to retrieve copies of the documents. An indication of the relevant sections may also be included but is not required.
              </t>
            </list>
          </t>
        </section>
        <section anchor="IANATokenTypeMappingsInitial" title="Initial Registry Contents">
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">Bearer</spanx></t>
              <t>Mapped value: 1</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">pop</spanx></t>
              <t>Mapped value: 2</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
        </section>
      </section>

      <section anchor="IANAJWTClaims" title="CBOR Web Token Claims">
	<t>This specification registers the following new claims in the CBOR
	Web Token (CWT) registry:</t>
	<t>
	  <?rfc subcompact="yes"?>
          <list style='symbols'>
            <t>Claim Name: <spanx style="verb">scope</spanx></t>
            <t>Claim Description: The scope of an access token as
	    defined in <xref target="RFC6749"/>.</t>
            <t>Change Controller: IESG</t>
            <t>Specification Document(s): this document</t>
          </list>
	</t>
	<t>
	  <?rfc subcompact="yes"?>
          <list style='symbols'>
            <t>Claim Name: <spanx style="verb">cnf</spanx></t>
            <t>Claim Description: The proof-of-possession key of an access
	    token as defined in <xref target="RFC7800"/>.</t>
            <t>Change Controller: IESG</t>
            <t>Specification Document(s): this document</t>
          </list>
	</t>
      </section>

      <section anchor="IANATokenEndpointCBORMappingsRegistry" title="ACE Profile Registry">
        <t>A new registry will be requested from IANA, entitled "ACE Profile Registry".  The registry is to be created as Expert Review Required.</t>

        <section anchor="IANATokenEndpointCBORMappingsRegistryTemplate" title="Registration Template">
          <t>
            <list style='hanging'>
              <t hangText='Profile name:'>
                <vspace/>
                Name of the profile to be included in the profile attribute.
              </t>
              <t hangText='Profile description:'>
                <vspace/>
                Text giving an over view of the profile and the context it is developed for.
              </t>
              <t hangText='Profile ID:'>
                <vspace/>
                Integer value to identify the profile.  The value MUST be an integer in the range of 1 to 65536.
              </t>
              <t hangText='Change Controller:'>
                <vspace/>
                For Standards Track RFCs, list the "IESG". For others, give the name of the responsible party. Other details (e.g., postal address, email address, home page URI) may also be included.
              </t>
              <t hangText='Specification Document(s):'>
                <vspace/>
                Reference to the document or documents that specify the parameter,preferably including URIs that can be used to retrieve copies of the documents. An indication of the relevant sections may also be included but is not required.
              </t>
            </list>
          </t>
        </section>
      </section>

      <section anchor="IANAOAuthParameterMappingsRegistry" title="OAuth Parameter Mappings Registry">
        <t>A new registry will be requested from IANA, entitled "Token Endpoint CBOR Mappings Registry".  The registry is to be created as Expert Review Required.</t>

        <section anchor="IANAOAuthParameterMappingsRegistryTemplate" title="Registration Template">
          <t>
            <list style='hanging'>
              <t hangText='Parameter name:'>
                <vspace/>
                OAuth Parameter name, refers to the name in the OAuth parameter registry e.g. "client_id".
              </t>
              <t hangText='CBOR key value:'>
                <vspace/>
                Key value for the claim.  The key value MUST be an integer in the range of 1 to 65536.
              </t>
              <t hangText='Change Controller:'>
                <vspace/>
                For Standards Track RFCs, list the "IESG". For others, give the name of the responsible party. Other details (e.g., postal address, email address, home page URI) may also be included.
              </t>
              <t hangText='Specification Document(s):'>
                <vspace/>
                Reference to the document or documents that specify the parameter,preferably including URIs that can be used to retrieve copies of the documents. An indication of the relevant sections may also be included but is not required.
              </t>
            </list>
          </t>
        </section>

        <section anchor="IANATokenEndpointCBORMappingsRegistryInitial"
		 title="Initial Registry Contents">
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">aud</spanx></t>
              <t>CBOR key value: 3</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">client_id</spanx></t>
              <t>CBOR key value: 8</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">client_secret</spanx></t>
              <t>CBOR key value: 9</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">response_type</spanx></t>
              <t>CBOR key value: 10</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">redirect_uri</spanx></t>
              <t>CBOR key value: 11</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">scope</spanx></t>
              <t>CBOR key value: 12</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">state</spanx></t>
              <t>CBOR key value: 13</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">code</spanx></t>
              <t>CBOR key value: 14</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">error_description</spanx></t>
              <t>CBOR key value: 15</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">error_uri</spanx></t>
              <t>CBOR key value: 16</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">grant_type</spanx></t>
              <t>CBOR key value: 17</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">access_token</spanx></t>
              <t>CBOR key value: 18</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">token_type</spanx></t>
              <t>CBOR key value: 19</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">expires_in</spanx></t>
              <t>CBOR key value: 20</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">username</spanx></t>
              <t>CBOR key value: 21</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">password</spanx></t>
              <t>CBOR key value: 22</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">refresh_token</spanx></t>
              <t>CBOR key value: 23</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">cnf</spanx></t>
              <t>CBOR key value: 24</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">profile</spanx></t>
              <t>CBOR key value: 25</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>

        </section>
      </section>

      <section anchor="IANAIntrospectionEndpointCBORMappingsRegistry" title="Introspection Endpoint CBOR Mappings Registry">
        <t>A new registry will be requested from IANA, entitled "Introspection
	Endpoint CBOR Mappings Registry".  The registry is to be created as
	Expert Review Required.</t>

        <section anchor="IANAIntrospectionEndpointCBORMappingsRegistryTemplate" title="Registration Template">
          <t>
            <list style='hanging'>
              <t hangText='Response parameter name:'>
                <vspace/>
                Name of the response parameter as defined in the "OAuth Token Introspection Response" registry e.g. "active".
              </t>
              <t hangText='CBOR key value:'>
                <vspace/>
                Key value for the claim.  The key value MUST be an integer in the range of 1 to 65536.
              </t>
              <t hangText='Change Controller:'>
                <vspace/>
                For Standards Track RFCs, list the "IESG". For others, give the name of the responsible party. Other details (e.g., postal address, email address, home page URI) may also be included.
              </t>
              <t hangText='Specification Document(s):'>
                <vspace/>
                Reference to the document or documents that specify the parameter,preferably including URIs that can be used to retrieve copies of the documents. An indication of the relevant sections may also be included but is not required.
              </t>
            </list>
          </t>
        </section>

        <section anchor="IANAIntrospectionEndpointCBORMappingsRegistryInitial"
		 title="Initial Registry Contents">
	  <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">iss</spanx></t>
              <t>CBOR key value: 1</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
         <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">sub</spanx></t>
              <t>CBOR key value: 2</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">aud</spanx></t>
              <t>CBOR key value: 3</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
	  <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">exp</spanx></t>
              <t>CBOR key value: 4</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
	  <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">nbf</spanx></t>
              <t>CBOR key value: 5</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
	  <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">iat</spanx></t>
              <t>CBOR key value: 6</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
	  <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">cti</spanx></t>
              <t>CBOR key value: 7</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">client_id</spanx></t>
              <t>CBOR key value: 8</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">scope</spanx></t>
              <t>CBOR key value: 12</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">token_type</spanx></t>
              <t>CBOR key value: 19</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">username</spanx></t>
              <t>CBOR key value: 21</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
	  <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">cnf</spanx></t>
              <t>CBOR key value: 24</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
	  <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">profile</spanx></t>
              <t>CBOR key value: 25</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">token</spanx></t>
              <t>CBOR key value: 26</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
	  <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">token_type_hint</spanx></t>
              <t>CBOR key value: 27</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>  
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">active</spanx></t>
              <t>CBOR key value: 28</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">client_token</spanx></t>
              <t>CBOR key value: 29</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">rs_cnf</spanx></t>
              <t>CBOR key value: 30</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
        </section>
      </section>
      <section anchor="CoAPOptionNumberRegistration" title="CoAP Option Number Registration">
      	<t>
      	  This section registers the "Access-Token" CoAP Option Number
	  in the "CoRE Parameters" sub-registry "CoAP Option Numbers" in
	  the manner described in <xref target="RFC7252"/>.
      	</t>
        <t>
          <list style="hanging">
            <t hangText="Name"><vspace blankLines="1"/>
              Access-Token
           </t>
            <t hangText="Number"><vspace blankLines="1"/>
              TBD
            </t>
            <t hangText="Reference"><vspace blankLines="1"/>
              [This document].
            </t>
            <t hangText="Meaning in Request"><vspace blankLines="1"/>
              Contains an Access Token according to [This document]
              containing access permissions of the client.
            </t>
            <t hangText="Meaning in Response"><vspace blankLines="1"/>
              Not used in response
            </t>
            <t hangText="Safe-to-Forward"><vspace blankLines="1"/>
              Yes
            </t>
            <t hangText="Format"><vspace blankLines="1"/>
              Based on the observer the format is perceived differently.
              Opaque data to the client and CWT or reference token to the RS.
            </t>
            <t hangText="Length"><vspace blankLines="1"/>
              Less then 255 bytes
            </t>
          </list>
        </t>
      </section>
    </section>


    <section anchor="Acknowledgments" title="Acknowledgments">
        <t>We would like to thank Eve Maler for her contributions to the use of
        OAuth 2.0 and UMA in IoT scenarios, Robert Taylor for his discussion
        input, and Malisa Vucinic for his input on the ACRE proposal
	<xref target="I-D.seitz-ace-core-authz"/> which was one source of
        inspiration for this work. Finally, we would like to thank the ACE
        working group in general for their feedback.</t>

	<t>Ludwig Seitz and Goeran Selander worked on this document as part of
	the CelticPlus project CyberWI, with funding from Vinnova.</t>
    </section>

    <!-- Possibly a 'Contributors' section ... -->
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
      &I-D.ietf-cose-msg;

      &I-D.selander-ace-object-security;

      &I-D.ietf-ace-cbor-web-token;

      &RFC7662;

      &RFC2119;

      &RFC6347;

      &RFC7252;

      &RFC7800;

    </references>

    <references title="Informative References">
      <!-- Here we use entities that we defined at the beginning. -->
      <!-- &I-D.ietf-ace-usecases;
      &RFC7250;

-->
      &I-D.seitz-ace-core-authz;

      &I-D.ietf-ace-actors;

      &I-D.ietf-core-block;

      &RFC4949;

      &RFC5246;

      &RFC6690;

      &RFC6749;

      &RFC6819;

      &RFC7049;

      &RFC7159;

      &RFC7228;

      &RFC7231;

      &RFC7519;

      &RFC7591;

      &RFC7744;

    </references>

    <section title="Design Justification" anchor="constraints">

     <t>This section provides further insight into the design decisions
     of the solution documented in this document.  <xref target="overview"/>
     lists several building blocks and briefly summarizes their importance.
     The justification for offering some of those building blocks, as opposed
     to using OAuth 2.0 as is, is given below.</t>

     <t>Common IoT constraints are:

        <list style="hanging">

          <t hangText="Low Power Radio:"><vspace blankLines="1"/>
          Many IoT devices are equipped with a small battery which needs
          to last for a long time.  For many constrained wireless devices the
          highest energy cost is associated to transmitting or receiving
          messages.  It is therefore important to keep the total communication
          overhead low, including minimizing the number and size of messages
          sent and received, which has an impact of choice on the message format
          and protocol.  By using CoAP over UDP, and CBOR encoded messages
          some of these aspects are addressed.  Security protocols contribute
          to the communication overhead and can in some cases be
          optimized.  For example authentication and key establishment may in
          certain cases where security requirements so allows be replaced by
          provisioning of security context by a trusted third party, using
          transport or application layer security.<vspace blankLines="0"/>
          </t>

          <t hangText="Low CPU Speed:"><vspace blankLines="1"/>
          Some IoT devices are equipped with processors that are significantly
          slower than those found in most current devices on the Internet.
          This typically has implications on what timely cryptographic
          operations a device is capable to perform, which in turn impacts
          e.g. protocol latency.  Symmetric key cryptography may be used
          instead of the computationally more expensive public key cryptography
          where the security requirements so allows, but this may also require
          support for trusted third party assisted secret key establishment
          using transport or application layer security.
	  <vspace blankLines="0"/>
          </t>

          <t hangText="Small Amount of Memory:"> <vspace blankLines="1"/>
          Microcontrollers embedded in IoT devices are often equipped with
          small amount of RAM and flash memory, which places limitations what
          kind of processing can be performed and how much code can be put on
          those devices.  To reduce code size fewer and smaller protocol
          implementations can be put on the firmware of such a device.  In
          this case, CoAP may be used instead of HTTP,  symmetric key
          cryptography instead of public key cryptography, and CBOR instead of
          JSON.  Authentication and key establishment protocol, e.g. the DTLS
          handshake,  in comparison with assisted key establishment also has
          an impact on memory and code.<vspace blankLines="0"/>
          </t>

          <t hangText="User Interface Limitations:"> <vspace blankLines="1"/>
          Protecting access to resources is both an important security as well
          as privacy feature.  End users and enterprise customers do not want
          to give access to the data collected by their IoT device or to
          functions it may offer to third parties.  Since the classical
          approach of requesting permissions from end users via a rich user
          interface does not work in many IoT deployment scenarios these
          functions need to be delegated to user controlled devices that are
          better suitable for such tasks, such as smart phones and tablets.
	  <vspace blankLines="0"/></t>

          <t hangText="Communication Constraints:"> <vspace blankLines="1"/>
          In certain constrained settings an IoT device may not be able to
          communicate with a given device at all times.  Devices may be
          sleeping, or just disconnected from the Internet because of general
          lack of connectivity in the area, for cost reasons, or for security
          reasons, e.g. to avoid an entry point for Denial-of-Service attacks.

          <vspace blankLines="1"/>
          The communication interactions this framework builds upon (as shown
          graphically in <xref target="fig:protocolFlow"/>) may be accomplished
          using a variety of different protocols, and not all parts of the
          message flow are used in all applications due to the communication
          constraints.  While we envision deployments to make use of CoAP we
          explicitly want to support HTTP, HTTP/2 or specific protocols, such
          as Bluetooth Smart communication, which does not necessarily use
          IP.  The latter raises the  need for application layer security over
          the various interfaces.
          </t>

        </list>
      </t>

    </section>

    <section anchor="app:rolesAndResponsibilities" title="Roles and Responsibilites">
      <t><list style="hanging">
	<t hangText="Resource Owner">
	  <list style="symbols">
	    <t>Make sure that the RS is registered at the AS.  This includes
	    making known to the AS which profiles, token_types, scopes, and
	    key types (symmetric/asymmetric) the RS supports. Also making
	    it known to the AS which audience(s) the RS identifies itself
	    with.</t> 
	    <t>Make sure that clients can discover the AS which is in charge
	    of the RS.</t>
	    <t>Make sure that the AS has the necessary, up-to-date, access
	    control policies for the RS.</t>
	  </list>
	  <vspace blankLines="0"/>
	</t>
	<t hangText="Requesting Party">
	  <list style="symbols">
	    <t>Make sure that the client is provisioned the necessary
	    credentials to authenticate to the AS.</t>
	    <t>Make sure that the client is configured to follow the security
	    requirements of the Requesting Party, when issuing requests
	    (e.g. minimum communication security requirements, trust
	    anchors).</t>
	    <t>Register the client at the AS.  This includes making known to
	    the AS which profiles, token_types, and key types
	    (symmetric/asymmetric) the client.</t>
          </list>
	  <vspace blankLines="0"/>
        </t>
	<t hangText="Authorization Server">
	  <list style="symbols">
	    <t>Register RS and manage corresponding security contexts.</t>
            <t>Register clients and including authentication credentials.</t>
	    <t>Allow Resource Owners to configure and update access control
	    policies related to their registered RS'</t>
	    <t>Expose the /token endpoint to allow  clients to request
	    tokens.</t> 
            <t>Authenticate clients that wish to request a token.</t>
	    <t>Process a token request against the authorization
	    policies configured for the RS.</t>
	    <t>Expose the /introspection endpoint that allows RS's to submit
	    token introspection requests.</t>
	    <t>Authenticate RS's that wish to get an introspection
	    response.</t>
	    <t>Process token introspection requests.</t>
	    <t>Optionally: Handle token revocation.</t>
          </list><vspace blankLines="0"/>
	</t>
        <t hangText="Client">
	  <list style="symbols">
	    <t>Discover the AS in charge of the RS that is to be targeted with
	    a request.</t>
            <t>Submit the token request (A).
	      <list style="symbols">
		<t>Authenticate towards the AS.</t>
		<t>Optionally (if not pre-configured): Specify which RS, which
		resource(s), and which action(s) the request(s) will
		target.</t> 
		<t>If raw public key (rpk) or certificate is used, make sure
		the AS has the right rpk or certificate for this client.</t>
	      </list>
	    </t>
	    <t>Process the access token and RS Information (B)
	       <list style="symbols">
		<t>Check that the RS Information provides the necessary
		security parameters (e.g. PoP key, information on
		communication security protocols supported by the RS).</t>
	      </list>
	    </t>
	    <t>Send the token and request to the RS (C)
	      <list style="symbols">
		<t>Authenticate towards the RS (this could coincide with the
		proof of possession process).</t>
		<t>Transmit the token as specified by the AS (default is to the
		/authz-info endpoint, alternative options are specified by
		profiles).</t>
		<t>Perform the proof-of-possession procedure as specified by
		the profile in use (this may already have been taken care
		of through the authentication procedure).</t>
	      </list>
	    </t>
	    <t>Process the RS response (F)
	    requirements of the Requesting Party, when issuing requests
	    (e.g. minimum communication security requirements, trust
	    anchors).</t>
	    <t>Register the client at the AS.</t>
          </list><vspace blankLines="0"/>
	</t>
	<t hangText="Resource Server">
	  <list style="symbols">
	    <t>Expose a way to submit access tokens. By default this is 
	    the /authz-info endpoint.</t>
            <t>Process an access token.
	      <list style="symbols">
		<t>Verify the token is from the right AS.</t>
		<t>Verify that the token applies to this RS.</t>
		<t>Check that the token has not expired (if the token provides
		expiration information).</t>
		<t>Check the token's integrity.</t>
		<t>Store the token so that it can be retrieved in the context
		of a matching request.</t>
	      </list>
	    </t>
	    <t>Process a request.
	     <list style="symbols">
	        <t>Set up communication security with the client.</t>
		<t>Authenticate the client.</t>
		<t>Match the client against existing tokens.</t>
		<t>Check that tokens belonging to the client actually
		authorize the requested action.</t>
		<t>Optionally: Check that the matching tokens are still valid
		(if this is possible.)</t>
	      </list>
	    </t>
	    <t>Send a response following the agreed upon communication
	    security.</t> 
          </list>
	</t>
      </list></t>
    </section>

<!-- ***************************************************** -->
<section anchor="profileRequirements" title="Requirements on Profiles">
  <t>This section lists the requirements on profiles of this framework,
  for the convenience of a profile designer.  All this information is
  also given in the appropriate sections of the main document, this 
  is just meant as a checklist, to make it more easy to spot parts one
  might have missed.
  
  <list style="symbols">
    <t>Specify the discovery process of how the client finds the
    right AS for an RS it wants to send a request to.</t>

    <t>Specify the communication protocol the client and RS the must use
    (e.g. CoAP).</t>

    <t>Specify the security protocol the client and RS must use to protect
    their communication (e.g. OSCOAP or DTLS over CoAP).  This must provide
    encryption and integrity protection.</t>

    <t>Specify how the client and the RS mutually authenticate</t>

    <t>Specify the Content-format of the protocol messages
    (e.g. "application/cbor" or "application/cose+cbor").</t>

    <t>Specify the proof-of-possession protocol(s) and how to select one,
    if several are available.  Also specify which key types
    (e.g. symmetric/asymmetric) are supported by a specific proof-of-possession
    protocol.</t>

    <t>Specify a unique profile identifier.</t>

    <t>Optionally specify how the RS talks to the AS for introspection.</t>
    
    <t>Optionally specify how the client talks to the AS for requesting a
    token.</t> 

    <t>Specify how/if the /authz-info endpoint is protected.</t>
    
    <t>Optionally define other methods of token transport than the /authz-info
    endpoint.</t>

  </list>

  </t>


</section>
      


<!-- ***************************************************** -->
      <section anchor="options" title="Deployment Examples">
        <t>There is a large variety of IoT deployments, as is indicated in
        <xref target="constraints"/>, and this section highlights a few common
        variants.  This section is not normative but illustrates how the
        framework can be applied.
        </t>

        <t>For each of the deployment variants there are a number of possible
        security setups between clients, resource servers and authorization
        servers.  The main focus in the following subsections is on how
        authorization of a client request for a resource hosted by a RS is
        performed.  This requires the the security of the requests and
        responses between the clients and the RS to consider.
        </t>

        <t>Note: CBOR diagnostic notation is used for examples of requests
          and responses.</t>

<!-- ************************** -->


 <!-- ************************** -->
<section anchor="localTokenValidation" title="Local Token Validation">
  <t>In this scenario we consider the case where the resource server is offline,
i.e. it is not connected to the AS at the time of the access request.
This access procedure involves steps A, B, C, and F of <xref target="fig:protocolFlow"/>.
  </t>

  <t>Since the resource server must be able to verify the access token locally,
  self-contained access tokens must be used.</t>

    <t>This example shows the interactions between a client, the
    authorization server and a temperature sensor acting as a resource server.  Message
    exchanges A and B are shown in <xref target="fig:RSOffline"/>.</t>

    <t><list style="hanging">
      <t>A: The client first generates a public-private key pair used for
      communication security with the RS.</t>

      <t>The client sends the POST request to /token at the AS.  The security
        of this request can be transport or application layer, it is up the
        the comunication security profile to define. In the example trasport
        layer identification of the AS is done and the client identifies with
        client_id and client_secret as in classic OAuth.  The request
      contains the public key of the client and the Audience parameter set to
      "tempSensorInLivingRoom", a value that the temperature sensor
      identifies itself with.  The AS evaluates the request and authorizes the
      client to access the resource.</t>

      <t>B: The AS responds with a PoP token and RS Information.  The PoP
      token contains the public key of the client, and the RS Information
      contains the public key of the RS.  For communication security
      this example uses DTLS RawPublicKey between the client and the RS. The issued
      token will have a short validity time, i.e. 'exp' close to 'iat',
      to protect the RS from replay attacks. The token includes
      the claim such as "scope" with the authorized access that an owner of the
      temperature device can enjoy.  In this example, the 'scope' claim, issued
      by the AS, informs the RS that the owner of the token, that can prove
      the possession of a key is authorized to make a GET request
      against the /temperature resource and a POST request on the /firmware
      resource.  Note that the syntax and semantics of the scope claim
      are application specific.</t>

      <t>Note: In this example we assume that the client knows what resource it
      wants to access, and is therefore able to request specific
      audience and scope claims for the access token.</t>
    </list></t>

    <t><figure align="center" anchor="fig:RSOffline"
               title="Token Request and Response Using Client Credentials.">
        <artwork align="left"><![CDATA[
         Authorization
  Client    Server
    |         |
    |<=======>| DTLS Connection Establishment
    |         |   to identify the AS
    |         |
A:  +-------->| Header: POST (Code=0.02)
    |  POST   | Uri-Path:"token"
    |         | Content-Type: application/cbor
    |         | Payload: <Request-Payload>
    |         |
B:  |<--------+ Header: 2.05 Content
    |  2.05   | Content-Type: application/cbor
    |         | Payload: <Response-Payload>
    |         |
        ]]></artwork>
    </figure></t>

    <t>The information contained in the Request-Payload and the
    Response-Payload is shown in <xref target="fig:RSOfflineReq"/>.
    Note that we assume a DTLS-based communication security profile for this
    example, therefore the Content-Type is "application/cbor".

     <figure align="center" anchor="fig:RSOfflineReq"
             title="Request and Response Payload Details.">
      <artwork align="left"><![CDATA[
Request-Payload :
{
  "grant_type" : "client_credentials",
  "aud" : "tempSensorInLivingRoom",
  "client_id" : "myclient",
  "client_secret" : "qwerty"
}

Response-Payload :
{
  "access_token" : b64'SlAV32hkKG ...',
  "token_type" : "pop",
  "csp" : "DTLS",
  "cnf" : {
    "COSE_Key" : {
      "kid" : b64'c29tZSBwdWJsaWMga2V5IGlk',
      "kty" : "EC",
      "crv" : "P-256",
      "x"   : b64'MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqv7D4',
      "y"   : b64'4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM'
    }
  }
}
        ]]></artwork>
    </figure></t>

    <t>The content of the access token is shown
    in  <xref target="fig:BothcborMappingValueAsymmetricCWT"/>.</t>

    <t><figure align="center"
               anchor="fig:BothcborMappingValueAsymmetricCWT"
               title="Access Token including Public Key of the Client.">
        <artwork align="left"><![CDATA[
{
  "aud" : "tempSensorInLivingRoom",
  "iat" : "1360189224",
  "exp" : "1360289224",
  "scope" :  "temperature_g firmware_p",
  "cnf" : {
    "jwk" : {
      "kid" : b64'1Bg8vub9tLe1gHMzV76e8',
      "kty" : "EC",
      "crv" : "P-256",
      "x" : b64'f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU',
      "y" : b64'x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0'
    }
  }
}
        ]]></artwork>
    </figure></t>

    <t>Messages C and F are shown in
    <xref target="fig:RSOfflinePostAccessTokenAsymmetric"/> -
    <xref target="fig:RSOfflineDTLSRequestAndResponse"/>.

    <list style="hanging">
      <t>C: The client then sends the PoP token to the /authz-info endpoint at
      the RS.  This is a plain CoAP request, i.e. no transport or application
      layer security between client and RS, since the token is integrity protected
      between AS and RS.  The RS verifies that the PoP token was created by a
      known and trusted AS, is valid, and responds to the client.  The RS caches
      the security context together with authorization information about this client
      contained in the PoP token.</t>

    <t><figure align="center" anchor="fig:RSOfflinePostAccessTokenAsymmetric"
               title="Access Token provisioning to RS">
      <artwork align="left"><![CDATA[
           Resource
 Client     Server
    |         |
C:  +-------->| Header: POST (Code=0.02)
    |  POST   | Uri-Path:"authz-info"
    |         | Payload: SlAV32hkKG ...
    |         |
    |<--------+ Header: 2.04 Changed
    |  2.04   |
    |         |
]]></artwork>
    </figure></t>

      <t>The client and the RS runs the DTLS handshake using the raw
      public keys established in step B and C.</t>

      <t>The client sends the CoAP request GET to /temperature on RS over
      DTLS.  The RS verifies that the request is authorized, based on
      previously established security context.</t>

      <t>F: The RS responds with a resource representation over DTLS.</t>
    </list></t>

    <t><figure align="center" anchor="fig:RSOfflineDTLSRequestAndResponse"
               title="Resource Request and Response protected by DTLS.">
      <artwork align="left"><![CDATA[
           Resource
 Client     Server
    |         |
    |<=======>| DTLS Connection Establishment
    |         |   using Raw Public Keys
    |         |
    +-------->| Header: GET (Code=0.01)
    | GET     | Uri-Path: "temperature"
    |         |
    |         |
    |         |
F:  |<--------+ Header: 2.05 Content
    | 2.05    | Payload: <sensor value>
    |         |
      ]]></artwork>
    </figure></t>
</section>


 <!-- ************************** -->

<section anchor="introspectionAidedTokenValidation" title="Introspection Aided Token Validation">

  <t>In this deployment scenario we assume that a client is not able to
  access the AS at the time of the access request.  Since the RS is, however,
  connected to the back-end infrastructure it can make use of token
  introspection.  This access procedure involves steps A-F of
  <xref target="fig:protocolFlow"/>, but assumes steps A and B have been
  carried out during a phase when the client had connectivity to AS.
  </t>

  <t>Since the client is assumed to be offline, at least for a certain period of
  time, a pre-provisioned access token has to be long-lived.  The resource
  server may use its online connectivity to validate the access token with the
  authorization server, which is shown in the example below.</t>

    <t>In the example interactions between an offline client
    (key fob), a RS (online lock), and an AS is shown.  We
    assume that there is a provisioning step where the client has access to the
    AS.  This corresponds to message exchanges A and B which are shown in
    <xref target="fig:cOffline"/>.
    </t>
    <t>Authorization consent from the resource owner can be pre-configured,
    but it can also be provided via an interactive flow with the resource
    owner.  An example of this for the key fob case could be that the
    resource owner has a connected car, he buys a generic key that he
    wants to use with the car.  To authorize the key fob he connects it
    to his computer that then provides the UI for the device.  After
    that OAuth 2.0 implicit flow can used to authorize the key for
    his car at the the car manufacturers AS.</t>

      <t>Note: In this example the client does not know the exact door it
        will be used to access since the token request is not send at the
        time of access. So the scope and audience parameters is set quite
        wide to start with and new values different form the
        original once can be returned from introspection later on.</t>
            <t>
      <list style="hanging">
        <t>A: The client sends the request using POST to /token at AS.  The
        request contains the Audience parameter set to  "PACS1337" (PACS, Physical Access System), a
        value the that the online door in question identifies itself with.  The
        AS generates an access token as on opaque string, which it can match to
        the specific client, a targeted audience and a symmetric key. The
        security is provided by identifying the AS on transport layer using
        a pre shared security context (psk, rpk or certificate) and then the
        client is identified using client_id and client_secret as in classic OAuth</t>

        <t>B: The AS responds with the an access token and RS Information,
        the latter containing a symmetric key.
        Communication security between C and RS will be DTLS and PreSharedKey.
        The PoP key being used as the PreSharedKey.
        </t>
      </list>
    </t>

    <t><figure align="center" anchor="fig:cOffline"
               title="Token Request and Response using Client Credentials.">
      <artwork align="left"><![CDATA[

         Authorization
 Client     Server
    |         |
    |         |
A:  +-------->| Header: POST (Code=0.02)
    |  POST   | Uri-Path:"token"
    |         | Content-Type: application/cbor
    |         | Payload: <Request-Payload>
    |         |
B:  |<--------+ Header: 2.05 Content
    |         | Content-Type: application/cbor
    |  2.05   | Payload: <Response-Payload>
    |         |
    ]]></artwork>
    </figure></t>

    <t>The information contained in the Request-Payload and the
    Response-Payload is shown in <xref target="fig:cOfflineReq"/>.

     <figure align="center" anchor="fig:cOfflineReq"
             title="Request and Response Payload for C offline">
      <artwork align="left"><![CDATA[
Request-Payload:
{
  "grant_type" : "client_credentials",
  "aud" : "lockOfDoor4711",
  "client_id" : "keyfob",
  "client_secret" : "qwerty"
}

Response-Payload:
{
  "access_token" : b64'SlAV32hkKG ...'
  "token_type" : "pop",
  "csp" : "DTLS",
  "cnf" : {
    "COSE_Key" : {
      "kid" : b64'c29tZSBwdWJsaWMga2V5IGlk',
      "kty" : "oct",
      "alg" : "HS256",
      "k": b64'ZoRSOrFzN_FzUA5XKMYoVHyzff5oRJxl-IXRtztJ6uE'
    }
  }
}
      ]]></artwork>
    </figure></t>

    <t>The access token in this case is just an opaque string referencing
   the authorization information at the AS.</t>

    <t><list style="hanging">
        <t>C: Next, the client POSTs the access token to the /authz-info
        endpoint in the RS.  This is a plain CoAP request, i.e. no
        DTLS between client and RS.  Since the token is an opaque string,
        the RS cannot verify it on its own, and thus defers to respond the
        client with a status code until after step E.</t>

        <t>D: The RS forwards the token to the /introspect
        endpoint on the AS.  Introspection assumes a secure connection
        between the AS and the RS, e.g. using transport of application layer
        security. In the example AS is identified using pre shared security
        context (psk, rpk or certificate) while RS is acting as client and
        is identified with client_id and client_secret.
        </t>

        <t>E: The AS provides the introspection response containing parameters
  about the token.  This includes the confirmation key (cnf) parameter
        that allows the RS to verify the client's proof of possession in
  step F.</t>

        <t>After receiving message E, the RS responds to the client's POST in
        step C with the CoAP response code 2.01 (Created).</t>

        <t><figure align="center" anchor="fig:cOfflineIntrospection"
            title="Token Introspection for C offline">
            <artwork align="left"><![CDATA[
           Resource
  Client    Server
    |         |
C:  +-------->| Header: POST (T=CON, Code=0.02)
    |  POST   | Uri-Path:"authz-info"
    |         | Content-Type: "application/cbor"
    |         | Payload: b64'SlAV32hkKG ...''
    |         |
    |         |     Authorization
    |         |       Server
    |         |          |
    |      D: +--------->| Header: POST (Code=0.02)
    |         |  POST    | Uri-Path: "introspect"
    |         |          | Content-Type: "application/cbor"
    |         |          | Payload: <Request-Payload>
    |         |          |
    |      E: |<---------+ Header: 2.05 Content
    |         |  2.05    | Content-Type: "application/cbor"
    |         |          | Payload: <Response-Payload>
    |         |          |
    |         |
    |<--------+ Header: 2.01 Created
    |  2.01   |
    |         |
]]></artwork>
        </figure></t>

        <t>The information contained in the Request-Payload and the
        Response-Payload is shown in <xref target="fig:cOfflineIntroReq"/>.

        <figure align="center" anchor="fig:cOfflineIntroReq"
                title="Request and Response Payload for Introspection">
          <artwork align="left"><![CDATA[
Request-Payload:
{
  "token" : b64'SlAV32hkKG...',
  "client_id" : "FrontDoor",
  "client_secret" : "ytrewq"
}

Response-Payload:
{
  "active" : true,
  "aud" : "lockOfDoor4711",
  "scope" : "open, close",
  "iat" : 1311280970,
  "cnf" : {
    "kid" : b64'JDLUhTMjU2IiwiY3R5Ijoi ...'
  }
}
          ]]></artwork>
        </figure></t>
      </list>
  </t>

<t>
    <list style="hanging">
        <t>
            The client uses the symmetric PoP key to establish a DTLS
            PreSharedKey secure connection to the RS. The CoAP request PUT is
            sent to the uri-path /state on RS changing state of the door to locked.
        </t>
        <t>
            F: The RS responds with a appropriate over the secure DTLS channel.
        </t>
    </list>
</t>
        <t><figure align="center" anchor="fig:cOfflineDTLSRequestAndResponse"
            title="Resource request and response protected by OSCOAP">
            <artwork align="left"><![CDATA[
           Resource
  Client    Server
    |         |
    |<=======>| DTLS Connection Establishment
    |         |   using Pre Shared Key
    |         |
    +-------->| Header: PUT (Code=0.03)
    | PUT     | Uri-Path: "state"
    |         | Payload: <new state for the lock>
    |         |
F:  |<--------+ Header: 2.04 Changed
    | 2.04    | Payload: <new state for the lock>
    |         |
            ]]></artwork>
        </figure></t>
    </section>

</section>
    <section anchor="app:changelog" title="Document Updates">
      <section anchor="app:f3t4" title="Version -02 to -03">
	<t><list style="symbols">
          <t>FIXME</t>
        </list></t>
      </section>
      <section anchor="app:f2t3" title="Version -01 to -02">
	<t><list style="symbols">
	  <t>Restructured to remove communication security parts.  These
	  shall now be defined in profiles.</t>
	  <t>Restructured section 5 to create new sections on the OAuth
	  endpoints /token, /introspect and /authz-info.</t>
	  <t>Pulled in material from draft-ietf-oauth-pop-key-distribution in
	  order to define proof-of-possession key distribution.</t>
	  <t>Introduced the 'cnf' parameter as defined in RFC7800 to reference
	  or transport keys used for proof of posession.</t>
	  <t>Introduced the 'client-token' to transport client information
	  from the AS to the client via the RS in conjunction with
	  introspection.</t>
	  <t>Expanded the IANA section to define parameters for token request,
	  introspection and CWT claims.</t>
	  <t>Moved deployment scenarios to the appendix as examples.</t>
	</list></t>
      </section>
      <section anchor="app:f1t2" title="Version -00 to -01">
	<t><list style="symbols">
	  <t>Changed 5.1. from "Communication Security Protocol" to "Client
	  Information".</t>
	  <t>Major rewrite of 5.1 to clarify the information exchanged between
	  C and AS in the PoP token request profile for IoT.
	  <list style="symbols">
	    <t>Allow the client to indicate preferences for the communication
	    security protocol.</t>
	    <t>Defined the term "Client Information" for the additional
	    information returned to the client in addition to the access
	    token.</t>
	    <t>Require that the messages between AS and client are secured,
	    either with (D)TLS or with COSE_Encrypted wrappers.</t>
	    <t>Removed dependency on OSCoAP and added generic text about
	    object security instead.</t>
	    <t>Defined the "rpk" parameter in the client information to
	    transmit the raw public key of the RS from AS to client.</t>
	    <t>(D)TLS MUST use the PoP key in the handshake (either as
	    PSK or as client RPK with client authentication).</t>
	    <t>Defined the use of x5c, x5t and x5tS256 parameters when a
	    client certificate is used for proof of possession.</t>
	    <t>Defined "tktn" parameter for signaling for how to transfer the
	    access token.</t>
	  </list></t>
	  <t>Added 5.2. the CoAP Access-Token option for transferring access
	  tokens in messages that do not have payload.</t>
	  <t>5.3.2. Defined success and error responses from the RS when
	  receiving an access token.</t>
	  <t>5.6.:Added section giving guidance on how to handle token
	  expiration in the absence of reliable time.</t>
	  <t>Appendix B Added list of roles and responsibilities for C, AS and
	  RS.</t>
	</list></t>
      </section>
    </section>
  </back>
</rfc>
